\documentclass[a4paper]{article}
\usepackage{forest}
\usepackage{float}
\usepackage{geometry}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{ragged2e}
\usepackage{color}
\usepackage{xepersian}
\usepackage{subfiles}
\newgeometry{left=1.4cm, right=1.4cm, bottom=2.0cm, top=2.0cm}
\settextfont[Scale=1]{XB Roya}

\input{config}

\title{معماری مقیاس بزرگ \\ خانم دکتر سحر آدابی}
\author{علیرضا سلطانی نشان}

\begin{document}
\maketitle
\tableofcontents

\section*{مجوز}

به فایل license همراه این برگه توجه کنید. این برگه تحت مجوز GPLv3 منتشر شده است
که اجازه نشر و استفاده (کد و خروجی/pdf) را رایگان می‌دهد.

\section{پیشگفتار}

اگر درس مهندسی نیازمندی‌ها را خوانده باشید، احتمالاً در جریان آن هستید که برای
تولید نرم‌افزار بخش‌های زیادی درگیر هستند اما در حالت کلی در درس پیشین دانستیم
که در ابتدا بایستی نیازمندی‌های مشتری یا کارفرما را از محصول نرم‌افزار بدانیم،
آن را بررسی و تحلیل کنیم، سند نیازمندی آن را آماده‌سازی کنیم و سپس به دنبال
طراحی معماری آن برویم. در این درس به طراحی و پیاده‌سازی سند معماری مقیاس بزرگ یک
محصول نرم‌افزاری می‌پردازیم تا فرایند تولید نرم‌افزار را به طور کامل طی کرده
باشیم.

\section{معرفی}

\subsection{چه زمانی یک پروژه مقیاس بزرگ است؟}

برای اینکه بتوانیم بگوییم که چه پروژه‌ای مقایس بزرگ محسوب می‌شود، براساس دو
استاندارد ایرانی و بین‌المللی می‌توان دو استاندارد را در اینجا مطرح کرد:

\begin{itemize}
    \item استاندارد مقیاس بزرگ بودن پروژه از نظر دکتر شمس، آن است که پروژه بیشتر
    از ۶ ماه زمان پیا‌ده‌سازی نیاز داشته باشد و تعداد درخواست‌های ارسالی به آن
    ۱۲ نفر به بالا باشد.
    \item استاندارد بین‌المللی مقیاس بزرگ بودن پروژه را زمان یک سال به بالا جهت
    پیاده‌سازی و تعداد درخواست‌ها را بین ۲۰ تا ۲۲ نفر تعیین می‌کند.
\end{itemize}

ابتدایی ترین فاز معماری یک محصول نرم‌افزاری مقیاس بزرگ، طراحی و بررسی و آنالیز
سناریو‌های آن است.

سند معماری نرم‌افزار به مجموعه‌ای از سناریو‌هایی گفته می‌شود که در ازای هر کدام
یک راه‌حل مناسب مطرح می‌شود.

یکی از نیازمندی‌های بررسی معماری نرم‌افزار مقیاس بزرگ استفاده از متدولوژی
\lr{RUP}\footnote{\lr{Rational Unified Process}} می‌باشد. دلیل اصلی آن این است
که می‌توان تمام فرایند‌های آن را به همراه \lr{Artifact}ها شخصی‌سازی کرد. در
معماری نرم‌افزار می‌توانیم مشخص کنیم که چه اجزایی داریم و این اجزا چگونه با
یکدیگر در ارتباط هستند و شامل چه قید‌هایی می‌شود. در حقیقت در سند معماری
نرم‌افزار نمود خارجی المان‌ها را مطرح می‌کنیم. نحوه در کنار هم چیدن سرویس‌ها را
مطرح می‌کنیم اما هیچ وقت در مورد جزئیات اینکه برای مثال از چه الگوریتم‌هایی
استفاده می‌کنیم، صحبت نمی‌شود. در این سند علاوه‌بر نیاز‌های جاری، در مورد
نیاز‌های آتی نیز صحبت می‌شود که در آینده چقدر باید نرم‌افزار قابلیت گسترش
\lr{Expandability} داشته باشد.

\subsection{یادآوری متدولوژوی \lr{RUP}}

این متدولوژوی به عنوان یک متدولوژوی توسعه نرم‌افزار اجایل، به دلیل قابل تکرار
بودنش در نظر گرفته شده است. این روش مهندسی نرم‌افزار از یک سیستم انعطاف پذیر و
سازگار در فرایند توسعه نرم‌افزار استفاده می‌کند که در برگیرنده انجام تنظیمات و
تکرار دوره‌های مهندسی نرم‌افزار است تا زمانی که محصول به نیازمندی‌های مطرح شده و
اهداف برسد \cite{rupStudy}.

\subsubsection{منظور از نظم در \lr{RUP}}

منظور از نظم در حقیقت نمود‌هایی می‌باشد که در فرایند توسعه نرم‌افزار مورد
استفاده قرار می‌گیرد، در حقیقت نظم، مدل‌سازی حرفه‌ای را نشان می‌دهد. این نظم‌ها
به ما کمک می‌کنند که چه زمانی چه \lr{Activity}هایی را باید به چه میزان در چه
بازه‌هایی انجام دهیم و خروجی مورد نظر ما چیست؟

برای مثال در فرایند تحلیل نیازمندی پروژه، نظم نیازمندی، خروجی فاز‌های آن است که
به شکل مدل‌های \lr{Usecase diagram} و سند معماری نرم‌افزار کشیده و نوشته شده
است.

\subsubsection{چهار فاز اصلی در \lr{RUP}}

\begin{enumerate}
    \item فاز آغاز یا \lr{Inception}: در این فاز تمام نیازمندی‌ها جمع‌آوری
    می‌شود و مقیاس پروژه در آن بدست می‌آید.
    \item فاز توسعه یا \lr{Elaboration}: طراحی سیستم و تحلیل دقیق‌تر نیازمندی‌ها
    صورت می‌گیرد.
    \begin{enumerate}
        \item استفاده از مدل‌سازی‌ها و کشیدن دیاگرام‌ها
        \item کشیدن مدل \lr{usecase}: کاربرد بزرگی برای مشتری (کارفرما) و طراح
        دارد و برای هر دو طرف قابل فهم می‌باشد. در این نوع نمودار افعال و
        نیازمندی‌های \lr{functional} مطرح می‌شود. انتظارات در مورد سیستم در
        اینجا مورد بحث قرار می‌گیرند.
        \begin{itemize}
            \item اینکه کاربرد بتواند زیر ۲ ثانیه احراز هویت شود مربوط به
            نیازمندی‌های \lr{non-functional} می‌باشد.
            \item شامل دو سند می‌شود:
            \begin{itemize}
                \item سند \lr{Usecase} که انتظارات سیستم را مشخص می‌کند.
                \item سند معماری که \lr{function} و \lr{non-functional} را در بر
                می‌گیرد.
            \end{itemize}
        \end{itemize}
        \item طراحی \lr{Class diagram} 
        \item طراحی \lr{Sequence diagram}
    \end{enumerate}
    \item فاز ساخت یا \lr{Construction}: در این فاز کد نویسی و ارزیابی کد‌های
    نوشته شده صورت می‌گیرد.
    \item فاز استقرار یا \lr{Deployment}: در این فاز نرم‌افزار آماده شده است و
    در بستری مناسب به کاربران نهایی \footnote{\lr{End users}} ارائه می‌شود که
    نیازمند آموزش‌های لازم می‌باشد.
\end{enumerate}

محبوبیت استفاده از متدولوژی \lr{RUP} به خاطر آن است که کاملاً به صورت جامع سیستم
را در بر می‌گیرد.

\subsubsection{منظور از فرسخ‌شمار چیست؟}

فرسخ‌شمار یا \lr{Milestone} در هر کدام از فاز‌ها مشخص می‌شود که در حقیقت در مورد
تعیین یک بازه زمانی مشخص صحبت می‌کند. در آن می‌توانیم ببینیم که در فاز‌های قبلی
چه کار‌هایی بایستی انجام می‌شده، آیا آن‌ها را انجام داده‌ایم و اگر انجام
نداده‌ایم یا مشکلی در آن وجود دارد آن فاز را تکرار می‌کنیم تا به انتهای آن برسیم
که به نحوی تسک یا وظیفه را ببندیم.

\subsubsection*{نکات}

\begin{itemize}
    \item ساده‌ترین سند در میان این ۴ فاز، سند استقرار می‌باشد.
    \item معماری مقیاس‌پذیر (بزرگ) یک پروژه نرم‌افزار دو بُعد پویا و ثابت دارد.
    \item در مورد ارزیابی کارایی و آزمون نرم‌افزار گفتنی است که هر توسعه‌دهنده
    مسئول \lr{Quality control} بخش خودش است.
    \item تکرار‌ها \lr{n} تا هستند مدیر پروژه یا طراح سیستم باید به ما تعداد
    تکرار‌ها را به صورت تقریبی بگوید.
\end{itemize}

\subsubsection{محوریت بر روی نیازمندی‌ها}

متدولوژوی \lr{RUP} تاکید زیادی روی شناسایی و مدیریت نیازمندی‌ها را دارد و به
تیم‌ها کمک می‌‌کند تا نیازمندی‌های کلیدی پروژه‌ را به خوبی درک و پیاده‌سازی
کنند.

\subsubsection{استفاده از برنامه‌نویسی \lr{OOP}}

این متدولوژی به طور گسترده از ۴ اصل شیء‌گرایی استفاده می‌کند و به توسعه‌دهندگان
اجازه می‌دهد که کد‌های قابل استفاده مجدد و مدیریت فاکتور‌های انعطاف پذیری را
ایجاد کنند.

\subsection{معماری نرم‌افزار چیست؟}

معماری نرم‌افزار یک تعریف واحد ندارد. معماری نرم‌افزار یک برنامه یا یک سیستم
محاسباتی می‌باشد. یک ساختار یا مجموعه ساختار‌هایی است از سیستم مورد نظر ما که
متشکل از المان‌های کامپیوتری است و نمود خارجی یک چیز (المان) می‌باشد و ارتباطات
بین آن‌ها را در بر می‌گیرد. هیچ‌گاه نمی‌توان نرم‌افزاری نوشت که معماری نرم‌افزار
نداشته باشد. برای مثال از معماری \lr{MVC} در نرم‌افزار خود استفاده کرده‌ایم.
نرم‌افزاری وجود ندارد که معماری نداشته باشد. اگر بگوییم نرم‌افزاری معماری ندارد
در حقیقت علم معماری به کار گرفته شده را نمی‌دانیم که آن را بی‌معماری می‌نامیم.
برای مثال معماری کلاینت سرور که براساس نیازمندی‌های نرم‌افزاری بیان می‌شود که چه
بخش‌هایی سمت سرور باشد چه‌ بخش‌هایی سمت کلاینت.

\subsection{المان‌ها}

بخش‌های یک سیستم نرم‌افزاری را گویند برای مثال یک نرم‌افزار واحد مانیتورینگ،
واحد زمان‌بندی، واحد بررسی درخواست‌ها و غیره را دارد.

\subsection{\lr{External Feasible Properties}}

آن بخش چه وظیفه‌ای را باید انجام دهد و آن بخش آن وظیفه را در حال انجام است یا
خیر؟ جزئیات مربوط به المان‌های درگیر در بخش معماری در \lr{External Feasible
Properties} مطرح نمی‌شود.

\subsection{تفاوت کامپوننت و المان}

وقتی در مورد کامپوننت می‌گوییم در حقیقت چیزی است که می‌خواهیم آن را پیاده‌سازی
کنیم. المان کامپوننتی است که قسمت اجرایی را برای آن در نظر نگرفته‌ایم.

\subsection{قابلیت اطمینان یا \lr{Reliability}}

یک سیستمی که در زمان مشخص درست کار کند به شرطی که در زمان $T - x$ درست کار کرده
باشد.

\subsection{قابلیت استفاده یا \lr{Useability}}

سیستمی که کارآمد باشد برای آن دسته از افرادی که سیستم را حاضر و آماده کرده‌ایم.
به گونه‌ای که با ظاهر مناسب کار کردن با آن نیز آسان باشد.

\subsection{ارائه سریع محصول یا \lr{Short time to market}}

قابلیت یا \lr{Feature} مجموعه‌ای از توابع نرم‌افزاری است که وقتی در بازار ارائه
می‌شود، واقعاً کار می‌کند. 

\subsubsection*{نکات}

\begin{itemize}
    \item تا آنجایی که می‌شود هزینه‌ها را باید کاهش بدهیم و بیشترین هزینه‌ها را
    ما در بخش توسعه نرم‌افزار خواهیم داشت. همیشه باید کارمندان را مشغول توسعه
    نگهداریم تا باعث از دست رفتن هزینه‌ها نشود.
    \item مشکل معمار آن است که حجم زیادی از نیازمندی‌های نرم‌افزاری را در حال
    بررسی است که نسبت به هم در تضاد هستند.
    \item بخشی از وظایف اصلی معماری نرم‌افزار مشخص کردن استک‌های نرم‌افزاری
    می‌باشد. بخش دیگری از آن این است که بررسی کند این موارد توسط تیم اجرا و
    استفاده می‌شود یا خیر (\lr{Follow up})
\end{itemize}

\subsection{تفاوت معماری سازمانی و معماری نرم‌افزار}

معماری سازمانی و معماری نرم‌افزار با یکدیگر متفاوت است. در معماری سازمانی، چارت
سازمانی آن مشخص‌کننده محدوده و کلیت هر قسمت آن سازمان می‌باشد.

% \lr{Mobile Adhoc Network}

% شبکه‌های موردی متحرک

% یک شبکه‌ای است فاقد زیرساخت. بیشتر در مناطق جنگی و \lr{Real-time} مورد استفاده
% قرار می‌گیرد که بتوانیم در حال حاضر یک شبکه را آماده کنیم که سربازان با یکدیگر
% ارتباط بگیرند به گونه‌ای که \lr{Mobility} بیان می‌کند که شبکه را بایستی با
% زیرساخت مناسب ایجاد کند.

% یک پیام «سلام» ارسال می‌کند و منتظر دریافت \lr{ACK} می‌باشد و بعد از آن سعی
% می‌کند که ارتباط را حفظ کند تا آن کانال ارتباطی بین سربازان برقرار باشد.

\newpage
\bibliographystyle{unsrt-fa}
\bibliography{refs.bib}
\end{document}