\documentclass[a4paper]{article}
\usepackage{forest}
\usepackage{float}
\usepackage{geometry}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{ragged2e}
\usepackage{color}
\usepackage{xepersian}
\usepackage{subfiles}
\newgeometry{left=1.4cm, right=1.4cm, bottom=2.0cm, top=2.0cm}
\settextfont[Scale=1]{XB Roya}

\input{config}

\title{معماری مقیاس بزرگ \\ خانم دکتر سحر آدابی}
\author{علیرضا سلطانی نشان}

\begin{document}
\maketitle
\tableofcontents

\section*{مجوز}

به فایل license همراه این برگه توجه کنید. این برگه تحت مجوز GPLv3 منتشر شده است
که اجازه نشر و استفاده (کد و خروجی/pdf) را رایگان می‌دهد.

\section{پیشگفتار}

اگر درس مهندسی نیازمندی‌ها را خوانده باشید، احتمالاً در جریان آن هستید که برای
تولید نرم‌افزار بخش‌های زیادی درگیر هستند اما در حالت کلی در درس پیشین دانستیم
که در ابتدا بایستی نیازمندی‌های مشتری یا کارفرما را از محصول نرم‌افزار بدانیم،
آن را بررسی و تحلیل کنیم، سند نیازمندی آن را آماده‌سازی کنیم و سپس به دنبال
طراحی معماری آن برویم. در این درس به طراحی و پیاده‌سازی سند معماری مقیاس بزرگ یک
محصول نرم‌افزاری می‌پردازیم تا فرایند تولید نرم‌افزار را به طور کامل طی کرده
باشیم.

\section{معرفی}

\subsection{چه زمانی یک پروژه مقیاس بزرگ است؟}

برای اینکه بتوانیم بگوییم که چه پروژه‌ای مقایس بزرگ محسوب می‌شود، براساس دو
استاندارد ایرانی و بین‌المللی می‌توان دو استاندارد را در اینجا مطرح کرد:

\begin{itemize}
    \item استاندارد مقیاس بزرگ بودن پروژه از نظر دکتر شمس، آن است که پروژه بیشتر
    از ۶ ماه زمان پیا‌ده‌سازی نیاز داشته باشد و تعداد درخواست‌های ارسالی به آن
    ۱۲ نفر به بالا باشد.
    \item استاندارد بین‌المللی مقیاس بزرگ بودن پروژه را زمان یک سال به بالا جهت
    پیاده‌سازی و تعداد درخواست‌ها را بین ۲۰ تا ۲۲ نفر تعیین می‌کند.
\end{itemize}

ابتدایی ترین فاز معماری یک محصول نرم‌افزاری مقیاس بزرگ، طراحی و بررسی و آنالیز
سناریو‌های آن است.

سند معماری نرم‌افزار به مجموعه‌ای از سناریو‌هایی گفته می‌شود که در ازای هر کدام
یک راه‌حل مناسب مطرح می‌شود.

یکی از نیازمندی‌های بررسی معماری نرم‌افزار مقیاس بزرگ استفاده از متدولوژی
\lr{RUP}\footnote{\lr{Rational Unified Process}} می‌باشد. دلیل اصلی آن این است
که می‌توان تمام فرایند‌های آن را به همراه \lr{Artifact}ها شخصی‌سازی کرد. در
معماری نرم‌افزار می‌توانیم مشخص کنیم که چه اجزایی داریم و این اجزا چگونه با
یکدیگر در ارتباط هستند و شامل چه قید‌هایی می‌شود. در حقیقت در سند معماری
نرم‌افزار نمود خارجی المان‌ها را مطرح می‌کنیم. نحوه در کنار هم چیدن سرویس‌ها را
مطرح می‌کنیم اما هیچ وقت در مورد جزئیات اینکه برای مثال از چه الگوریتم‌هایی
استفاده می‌کنیم، صحبت نمی‌شود. در این سند علاوه‌بر نیاز‌های جاری، در مورد
نیاز‌های آتی نیز صحبت می‌شود که در آینده چقدر باید نرم‌افزار قابلیت گسترش
\lr{Expandability} داشته باشد.

\subsection{یادآوری متدولوژوی \lr{RUP}}

این متدولوژوی به عنوان یک متدولوژوی توسعه نرم‌افزار اجایل، به دلیل قابل تکرار
بودنش در نظر گرفته شده است. این روش مهندسی نرم‌افزار از یک سیستم انعطاف پذیر و
سازگار در فرایند توسعه نرم‌افزار استفاده می‌کند که در برگیرنده انجام تنظیمات و
تکرار دوره‌های مهندسی نرم‌افزار است تا زمانی که محصول به نیازمندی‌های مطرح شده و
اهداف برسد \cite{rupStudy}.

\subsubsection{منظور از نظم در \lr{RUP}}

منظور از نظم در حقیقت نمود‌هایی می‌باشد که در فرایند توسعه نرم‌افزار مورد
استفاده قرار می‌گیرد، در حقیقت نظم، مدل‌سازی حرفه‌ای را نشان می‌دهد. این نظم‌ها
به ما کمک می‌کنند که چه زمانی چه \lr{Activity}هایی را باید به چه میزان در چه
بازه‌هایی انجام دهیم و خروجی مورد نظر ما چیست؟

برای مثال در فرایند تحلیل نیازمندی پروژه، نظم نیازمندی، خروجی فاز‌های آن است که
به شکل مدل‌های \lr{Usecase diagram} و سند معماری نرم‌افزار کشیده و نوشته شده
است.

\subsubsection{چهار فاز اصلی در \lr{RUP}}

\begin{enumerate}
    \item فاز آغاز یا \lr{Inception}: در این فاز تمام نیازمندی‌ها جمع‌آوری
    می‌شود و مقیاس پروژه در آن بدست می‌آید.
    \item فاز توسعه یا \lr{Elaboration}: طراحی سیستم و تحلیل دقیق‌تر نیازمندی‌ها
    صورت می‌گیرد.
    \begin{enumerate}
        \item استفاده از مدل‌سازی‌ها و کشیدن دیاگرام‌ها
        \item کشیدن مدل \lr{usecase}: کاربرد بزرگی برای مشتری (کارفرما) و طراح
        دارد و برای هر دو طرف قابل فهم می‌باشد. در این نوع نمودار افعال و
        نیازمندی‌های \lr{functional} مطرح می‌شود. انتظارات در مورد سیستم در
        اینجا مورد بحث قرار می‌گیرند.
        \begin{itemize}
            \item اینکه کاربرد بتواند زیر ۲ ثانیه احراز هویت شود مربوط به
            نیازمندی‌های \lr{non-functional} می‌باشد.
            \item شامل دو سند می‌شود:
            \begin{itemize}
                \item سند \lr{Usecase} که انتظارات سیستم را مشخص می‌کند.
                \item سند معماری که \lr{function} و \lr{non-functional} را در بر
                می‌گیرد.
            \end{itemize}
        \end{itemize}
        \item طراحی \lr{Class diagram} 
        \item طراحی \lr{Sequence diagram}
    \end{enumerate}
    \item فاز ساخت یا \lr{Construction}: در این فاز کد نویسی و ارزیابی کد‌های
    نوشته شده صورت می‌گیرد.
    \item فاز استقرار یا \lr{Deployment}: در این فاز نرم‌افزار آماده شده است و
    در بستری مناسب به کاربران نهایی \footnote{\lr{End users}} ارائه می‌شود که
    نیازمند آموزش‌های لازم می‌باشد.
\end{enumerate}

محبوبیت استفاده از متدولوژی \lr{RUP} به خاطر آن است که کاملاً به صورت جامع سیستم
را در بر می‌گیرد.

\subsubsection{منظور از فرسخ‌شمار چیست؟}

فرسخ‌شمار یا \lr{Milestone} در هر کدام از فاز‌ها مشخص می‌شود که در حقیقت در مورد
تعیین یک بازه زمانی مشخص صحبت می‌کند. در آن می‌توانیم ببینیم که در فاز‌های قبلی
چه کار‌هایی بایستی انجام می‌شده، آیا آن‌ها را انجام داده‌ایم و اگر انجام
نداده‌ایم یا مشکلی در آن وجود دارد آن فاز را تکرار می‌کنیم تا به انتهای آن برسیم
که به نحوی تسک یا وظیفه را ببندیم.

\subsubsection*{نکات}

\begin{itemize}
    \item ساده‌ترین سند در میان این ۴ فاز، سند استقرار می‌باشد.
    \item معماری مقیاس‌پذیر (بزرگ) یک پروژه نرم‌افزار دو بُعد پویا و ثابت دارد.
    \item در مورد ارزیابی کارایی و آزمون نرم‌افزار گفتنی است که هر توسعه‌دهنده
    مسئول \lr{Quality control} بخش خودش است.
    \item تکرار‌ها \lr{n} تا هستند مدیر پروژه یا طراح سیستم باید به ما تعداد
    تکرار‌ها را به صورت تقریبی بگوید.
\end{itemize}

\subsubsection{محوریت بر روی نیازمندی‌ها}

متدولوژوی \lr{RUP} تاکید زیادی روی شناسایی و مدیریت نیازمندی‌ها را دارد و به
تیم‌ها کمک می‌‌کند تا نیازمندی‌های کلیدی پروژه‌ را به خوبی درک و پیاده‌سازی
کنند.

\subsubsection{استفاده از برنامه‌نویسی \lr{OOP}}

این متدولوژی به طور گسترده از ۴ اصل شیء‌گرایی استفاده می‌کند و به توسعه‌دهندگان
اجازه می‌دهد که کد‌های قابل استفاده مجدد و مدیریت فاکتور‌های انعطاف پذیری را
ایجاد کنند.

\subsection{معماری نرم‌افزار چیست؟}

معماری نرم‌افزار یک تعریف واحد ندارد. معماری نرم‌افزار یک برنامه یا یک سیستم
محاسباتی می‌باشد. یک ساختار یا مجموعه ساختار‌هایی است از سیستم مورد نظر ما که
متشکل از المان‌های کامپیوتری است و نمود خارجی یک چیز (المان) می‌باشد و ارتباطات
بین آن‌ها را در بر می‌گیرد. هیچ‌گاه نمی‌توان نرم‌افزاری نوشت که معماری نرم‌افزار
نداشته باشد. برای مثال از معماری \lr{MVC} در نرم‌افزار خود استفاده کرده‌ایم.
نرم‌افزاری وجود ندارد که معماری نداشته باشد. اگر بگوییم نرم‌افزاری معماری ندارد
در حقیقت علم معماری به کار گرفته شده را نمی‌دانیم که آن را بی‌معماری می‌نامیم.
برای مثال معماری کلاینت سرور که براساس نیازمندی‌های نرم‌افزاری بیان می‌شود که چه
بخش‌هایی سمت سرور باشد چه‌ بخش‌هایی سمت کلاینت.

\subsection{المان‌ها}

بخش‌های یک سیستم نرم‌افزاری را گویند برای مثال یک نرم‌افزار واحد مانیتورینگ،
واحد زمان‌بندی، واحد بررسی درخواست‌ها و غیره را دارد.

\subsection{\lr{External Feasible Properties}}

آن بخش چه وظیفه‌ای را باید انجام دهد و آن بخش آن وظیفه را در حال انجام است یا
خیر؟ جزئیات مربوط به المان‌های درگیر در بخش معماری در \lr{External Feasible
Properties} مطرح نمی‌شود.

\subsection{تفاوت کامپوننت و المان}

وقتی در مورد کامپوننت می‌گوییم در حقیقت چیزی است که می‌خواهیم آن را پیاده‌سازی
کنیم. المان کامپوننتی است که قسمت اجرایی را برای آن در نظر نگرفته‌ایم.

\subsection{قابلیت اطمینان یا \lr{Reliability}}

یک سیستمی که در زمان مشخص درست کار کند به شرطی که در زمان $T - x$ درست کار کرده
باشد.

\subsection{قابلیت استفاده یا \lr{Useability}}

سیستمی که کارآمد باشد برای آن دسته از افرادی که سیستم را حاضر و آماده کرده‌ایم.
به گونه‌ای که با ظاهر مناسب کار کردن با آن نیز آسان باشد.

\subsection{ارائه سریع محصول یا \lr{Short time to market}}

قابلیت یا \lr{Feature} مجموعه‌ای از توابع نرم‌افزاری است که وقتی در بازار ارائه
می‌شود، واقعاً کار می‌کند. 

\subsubsection*{نکات}

\begin{itemize}
    \item تا آنجایی که می‌شود هزینه‌ها را باید کاهش بدهیم و بیشترین هزینه‌ها را
    ما در بخش توسعه نرم‌افزار خواهیم داشت. همیشه باید کارمندان را مشغول توسعه
    نگهداریم تا باعث از دست رفتن هزینه‌ها نشود.
    \item مشکل معمار آن است که حجم زیادی از نیازمندی‌های نرم‌افزاری را در حال
    بررسی است که نسبت به هم در تضاد هستند.
    \item بخشی از وظایف اصلی معماری نرم‌افزار مشخص کردن استک‌های نرم‌افزاری
    می‌باشد. بخش دیگری از آن این است که بررسی کند این موارد توسط تیم اجرا و
    استفاده می‌شود یا خیر (\lr{Follow up})
\end{itemize}

\subsection{تفاوت معماری سازمانی و معماری نرم‌افزار}

معماری سازمانی و معماری نرم‌افزار با یکدیگر متفاوت است. در معماری سازمانی، چارت
سازمانی آن مشخص‌کننده محدوده و کلیت هر قسمت آن سازمان می‌باشد.

% \lr{Mobile Adhoc Network}

% شبکه‌های موردی متحرک

% یک شبکه‌ای است فاقد زیرساخت. بیشتر در مناطق جنگی و \lr{Real-time} مورد استفاده
% قرار می‌گیرد که بتوانیم در حال حاضر یک شبکه را آماده کنیم که سربازان با یکدیگر
% ارتباط بگیرند به گونه‌ای که \lr{Mobility} بیان می‌کند که شبکه را بایستی با
% زیرساخت مناسب ایجاد کند.

% یک پیام «سلام» ارسال می‌کند و منتظر دریافت \lr{ACK} می‌باشد و بعد از آن سعی
% می‌کند که ارتباط را حفظ کند تا آن کانال ارتباطی بین سربازان برقرار باشد.

جزیئیات کار‌هایی که انجام میده:

ساخت چیزی هست به اسم بیزینس کیس

بیزینس پلن
چهارچوب سیستمی که داریم، اگر سیستمی مشابه این سیستم باشه سیستم ما چه چالش‌هایی
رو پاسخ میده.

سند بیزینس کیس

اینکه برآورد هزینه و توجیه اقتصادی

در گیر بودن نیرو‌ها رو بررسی میکنه و توجیح‌های اقتصادی از نظر کاهش هزینه‌ها رو
مطرح می‌کنه.

ممکن بیشتر اوقات بهره‌وری سیستم رو ببریم بالا اینم توجیح داره

بیزینس کیس جنس مالی داره و توجیح اقتصادی و برآورد هزینه‌ها رو درون آن می‌نویسیم.

چرا از فعالیت‌های معماری هستش.

از ابتدا تا انتهای پروژه دائماً در حال تخمین قیمت پروژه هستیم.

هزینه‌ای که فکر میکردیم نیاز میشه و در حین توسعه بیشتر یا کمتر شده یا سود داشتیم
یا ضرر.

break event point نقطه سر به سری

نقطه‌ای که هزینه‌ای که ما کردیم در آن بازه زمانی صفر میشه. مثلاً ۵۰۰ ممیلیون
هزینه نرم‌افزار میشه و یکسال دیگه سازمان ۵۰۰ میلیون رو سر به سر و صفر می‌کند. هر
چیزی که از break event point باشه میشه سود سرمایه. عدد اون ۲ تا ۵ سال برای
نرم‌افزار این مقدا زمانی خیلی زیاده. 

understanding the requirement

نیازمندی تنها متغیری است که ثابت است.

non-function در قالب سند معماری دیده میشود

همچنین اگر فانکشنی نباشه معنی نمیده. باید یه امن باشد یعنی یوز کسی داریم که به
ازای اون نان‌فانکشن تعریف می‌کنیم.

معمار تنها نیاز‌های جاری رو نمی‌بینه بلکه نیاز‌های آتی رو هم میبینه تا بتونه یک
فلو رو کامل کنه.

crating or selecting the architecture

یا انتخاب می‌کنیم یا می‌سازیم یک معماری رو.

ممکنه تو تز‌ها یک معماری ایجاد کنم. چون ممکنه صورت مسئله‌های جدیدی باشن یا
نان‌فانکشن‌های جدیدی دارن.

معماری‌ها رو یا باید بهینه کنیم یا اجرا کنیم.

Communicating the architecutre

چیزی که تو معماری بیان شده رو دنبال کنیم تمام اون فرایند‌های مهندسی نرم‌افزار رو
کسی دنبال می‌کنه یا نه. بیانش یک طرف هستش اجرای اون طرفی دیگه.

خیلی ارتباط با Implementing based on the architecutre

آیا ااون فازی که شروع میشه با بیانات معماری مطابقت داره یا نه

Ensuring conformance to an arch

تابع بود.

در انتهای کار تمام سند‌ها در کنار هم قرار می‌گیرد و تطبیق می‌دهد تا ببینه تماماً
با سند معماری اکس هستش یا نه. مثلاً تمام یوز‌کیسها مطابق با سند معماری یوز
کیس‌ها بوده؟ طبق استاندارد بوده؟ اگر نبوده باید اصلاح شود.

مطمئن باشیم که تمام سند‌هایی که به معمار تحویل داده میشه منطبق با سند معماری
هستش. شامل چندین بخش هستش.

معمار شخصی است که از ابتدا تا انتهای پروژه با ما هستش.

Analyzing or evaluating the arch

برای معماری شبیه‌سازی نداریم. غلطه بحثش. وقتی معنی پیدا می‌کنه، شبیه‌سازی معماری
نداریم. قدم اول هر پروژه‌ای معماری هستش چی رو می‌خوایم شبیه‌سازی کنیم. اینکه بگن
که معماریتون رو با چه معمار‌هایی شبیه‌سازی کردین یا با چه فاکتور‌هایی شبیه‌سازی
کردین غلطه. مقایسه بین الگوریتم‌ها امکان پذیر هستش چون داریم شبیه‌سازی انجام
میدیم. روش‌هایی و رو داریم مثل ATAM. اینا ارزیابی معماری انجام میدن. میان یه سری
نیاز‌های نان فانکشن رو در نظر میگیرن شبیه ایزو هستش. یه تیم پشته که ببینه ما
داریم درست میریم جلو. در نهایت بهمون میگه نسبت به اون سناریو میتونم این معمناری
رو کاور کنم. 

مدل‌سازی فرمال

استفاده از روش‌های فرمال صوری و رسمی به خاطر اینکه ثابت کنیم چیزی که داریم
می‌»ویسیم رو تایید کنیم.

چرا خوبه چون که ریاضیه

کلا به اینا میگن ADL Arch Definition Language

راه سوم: استفاده از پروتوتایپ هستش.یک سیستم کوچک درست کنیم اگر کار کرد سیستم
بزرگ‌هم کار میکنه.

راه چهارم:

۸۰ درصد نیازمندی‌ها و دامنه‌های مسئله با نرم‌افزاری که داره کار میکنه با این
معماری منطبق هستش پس صد دردص اون معماری با کار ما منطبق هستش.

دامنه مسئله مثل دامین سیستم‌های مالی دامین سیستم‌های آموزشی. سیستم‌های آموزشی
تعریف مسئله‌اش شبیه به هم هستش. نیازمند‌ی‌های هاش شبیه هم هستش.

اگر یک سیستم مشابه رو پیدا کردیم پس معماری انتخابی ما با سیستم مشابه هم کار
می‌کنه.

خیلی مهم بودن این فعالیت‌های معماری که تو حوزه‌های مختلفه

چه چیزی یک ممعاری را خوب نشان می‌دهد و بهتون تحویل میده؟

معماری کنترل دمای یک نیرو‌گاه تولید برق رو نمیشه توی خونمون استفاده کنیم چون
مچینگ بدی بوده.

هیچ چیزی ذاتاً خوب یا بد نیست بلکه کاربرد آن کاملاً وابستگی دارد.

پس این معماری چقدر فیت و مچ هستش که برای معماری ما مناسب باشه. 

ذاتاً نمیشه بگیم کدوم خوبه کدوم بده

انتخاب ما خوب و بد داره.

معماری قابل ارزیابی است پس باید بر اساس اهدافی که داریم ارزیابی کنیم. که ببینیم
این ارزیابی چقدر میتونه معماری رو مچ بکنه با اهداف ما.

نمیشه یه سامانه‌ای که امنیت نداره رو ببریم جایی که هدفش امنیته

اگه امنیت و پرفرمنس رو مد نظر داشته باشه ولی مال ما امنیت رو تنها میشه چون قشنگ
یک چیز رو اون نمونه‌ پوشش داده.

بخش‌های یک معاری نرم‌افزار:

المان‌ها

نمود خارجی المان‌ها اینکه چه وظیفه‌ای دارن.

و ارتباطات بین المان‌ها

اگر همچین شکلی رو تو پایان نامه داشته باشیم میشه به عنوان معماری دید؟ نه چون یه
ساختار کلی هستش.

چیزایی که نیستش:

ذات المان رو فاقد هستش.

مثلاً مشخص نیست واحد گرفتن کار قراره هم کارت بگیره و هم ولید بودنشو چک کنه؟ پس
نمود خارجیش مشخص نیست. یعنی مشخص نیست که وظیفش چیه؟

دقیقاً ماهیت ارتباطات بین المان‌ها مشخص نیست.

ارتباطات بین المان‌ها لیترالی با هم مشخص نیستن.

لایه بندی اینجا مشخص نیست. تو لایه بندی همیشه منطق هستش مثل لایه بندی OSI جا
نمایی المان‌ّا توی این دیاگرام مشخص نیست. مثلاً بحث امنیت و کارایی و تعامل‌پذیری
اصلاً توش وجود نداره.

لایه‌ها تماماً توسط توسعه دهنده مشخص میشه (ببخشید معمار)

% TODO: توی ۴ ۵ سال اخیر با کلمه arch ۴ ۵ تا مقاله معماری توی چند سال اخیر وجود
% داره که توشون معماری گفتن.

فالت یعنی یه نقضی که بلغوه در سیستم وجود دارد. زمانی بلفعل می‌شود که از سیستم
کار کشیده شود. وقتی بلفعل میشه یعنی failure شده.

زمانی که اتفاق بیوفته از فالت به فیلر تبدیل میشه. فالت بلقوه وجود داره ممکنه هم
سیستم کار کنه ولی به محض اینکه اتفاق میوفته میشه فیلیور. فالت از سمت دیزاین
همراه خواهد بوده چون باید تو سند‌های طراحی بهش نگاه میشه. زمانی که پیاده‌سازی
میشه تبدیل به failure میشه. اگر در شرایط تست بتونیم اون فالت‌ها رو بفهمیم میشه
فالت‌ها رو کمتر کرد.

یه فلش داشته فایل انتخاب می‌کرده که یه دفعه کشیدیش چون هیچی تو ش وجود نداره
درحقتقت نه ارورره نه فالت و نه فیلیره. چون عامل خارجی داشته. اتفاقی که تو سیستم
اتفاق میوفته.

همیشه یادمان باشد که فالت فیلیر ایجاد می‌کند.

(خیلی قشنگ گفت باید از بالایی‌ها درست بفهمم)

اگر فالتی داشته باشیم باید بتونیم هندلش کنیم.

definition implications

معاری المان‌های نرم‌افزار را مشخص می‌کند.

مپینگ تسک به منبع میشه زمان‌بندی

یه کار رو بگیر و بده به یه منبعی که با resource allocation هم شناخته می‌شود.

تعاریف توافق شده در کلاس:

task کار است

workflow مجموعه‌ای از تسک‌ها که به هم واستگی دارند. 

Task scheduling

workflow scheduling

bag of tasks عموماً واسبتگی ندارند

Multiple workflow scheduling: زمان‌بندی چند workflow

تعدادی زیادی درس تو دانشگاه داریم با ۱۰ تا کلاس تو دانشگاه زمانبندی برای درس‌ها
انجام میشه یعنی کلاس رو داریم تقسیم میکنیم که بهش داریم تو زمان‌های مشخص بهش تسک
اساین می‌کنیم.

یک زمانبندی بهینه نداریم.

تا اونجایی که می‌تونیم نرخ موفقیت یک تسک رو میخوایم بالا ببریم.

چون ماهیت تسک‌ها با هم متفاوت و ما معمولاً ملقمه‌آی از همه تسک‌ها داریم. به همین
دلیل الگوریتم‌های زمانبندی زیاد هستش.

یه وقت اولویت مطرح هستش.

منابع همگن یعنی همه یه سخت افزار‌ داریم و همه نرم‌افزاراشون same هستش. انگار یه
کلونی از هم دیگه هستن.

ناهمگن متفاوت بودن سیستم‌ها رو نسبت به هم میگن.

تز اول میتونه، الگوریتم اولویت‌دهی تسک‌ها باشه

مجموعه‌ای از تسک‌ها اومده کدوم تسک رو اساین بکنم به منبع task priority

تسکی که اندازه در آن مهم است. موقعیت در گراف مهم است.

ترکیبی از تسک‌های مهم و اولویت پایین روی هر منبعی داشته باشیم. اگه اون منبع با
شکست خود ری‌اسکژولینگ نکنه.

هفته بعد:

اولویت‌دهی منابع به عنوان تز گفته شود. فصل زمانبندی تننباوم رو بخونیم توی
ویژگی‌های کیفی و پرفورمنس اینا رو داریم.

ددلاین هم میتونه پایان در نظر گرفته بشه هم در ابتدا.


monitoring

Broaker

Resource monitoring

Receiving task

Task schedule

\newpage
\bibliographystyle{unsrt-fa}
\bibliography{refs.bib}
\end{document}