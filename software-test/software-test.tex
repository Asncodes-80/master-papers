\documentclass[a4paper]{article}
\usepackage{forest}
\usepackage{float}
\usepackage{geometry}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{ragged2e}
\usepackage{color}
\usepackage{xepersian}
\usepackage{subfiles}
\newgeometry{left=1.4cm, right=1.4cm, bottom=2.0cm, top=2.0cm}
\settextfont[Scale=1]{XB Roya}
\input{config}

\title{آزمون نرم‌افزار \\ خانم دکتر فرشته جدیدی میاندشتی}
\author{علیرضا سلطانی نشان}

\begin{document}
\maketitle
\tableofcontents

\section*{مجوز}

به فایل license همراه این برگه توجه کنید. این برگه تحت مجوز GPLv3 منتشر شده است
که اجازه نشر و استفاده (کد و خروجی/pdf) را رایگان می‌دهد.

\section{معرفی}

از روش‌هایی برای آزمون نرم‌افزار استفاده می‌کنیم که بالاترین ضریب اطمینان را به
توسعه دهنده و صاحب محصول نرم‌افزاری می‌دهد. اگر برای آزمون نرم‌افزار در فرایند
توسعه هزینه نکنیم (زمان و نیروی مناسب برای آن در نظر نگیریم)، در هنگام
\lr{Production} و استقرار نهایی مطمئناً چندین و چند برابرش را خواهیم پرداخت.

\subsubsection*{نکته}

\begin{itemize}
    \item آزمون نرم‌افزار کاملاً هزینه‌بر است.
    \item ضریب اطمینان هیچ چیز در امنیت به طور ۱۰۰ درصد تامین نمی‌شود.
    \item برای سیستم‌های مهم و بحرانی بایستی به طور کامل تمام استثنا‌ها را کنترل
    و مدیریت کرد (اشاره به تکنیک \lr{Exception handling}).
    \item بودجه‌ای که برای آزمون نرم‌افزار استفاده می‌کنیم ممکن است کم باشد ولی
    باید در نظر داشت که کار عاقلانه‌ای است که بودجه پروژه را به صورت متعادل بین
    توسعه و آزمون فرایند‌ها تقسیم کرد تا از تمام رخداد‌ها از قبل جلوگیری کرد.
    \item بیشتر اوقات نسخه آفا را کاربر آزمایش می‌کند و پیش‌پا افتاده‌ترین
    مشکلات و باگ‌ها را کاربران عادی متوجه می‌شوند و ممکن است به مدیر سیستم و
    نگهداری آن را گزارش دهند.
    \item برای آزمون نرم‌افزار $2^{n}$ راه را می‌توانیم بررسی کنیم اما هزینه و
    زمان زیادی را می‌تواند در بر گیرد.
    \begin{itemize}
        \item زمان زیاد منجر به افزایش هزیینه‌ها می‌شود.
    \end{itemize}
\end{itemize}

در این درس با روش‌های معمول آشنا می‌شویم که بالاترین ضریب اطمینان را برای آزمون
نرم‌افزار مورد نظر خود بدست آوریم. در حقیقت می‌توان گفت با انواع روش‌های آزمون
نرم‌افزار آشنا می‌شویم و سپس آزمونی را انتخاب می‌کنیم که بیشترین پوشش نرم‌افزاری
یا \lr{Coverage} را دارا می‌باشد.

\section{تعاریف اولیه}

\subsection{نیازمندی‌های آزمون نرم‌افزار یا \lr{Test Requirements}}

دقیقاً چه بخش‌هایی را می‌خواهیم مورد آزمون قرار دهیم؟ چه نیازی می‌خواهیم برآورده
شود؟ بطور کلی منظور موارد خاصی است که بایستی در طول آزمایش رعایت شوند یا پوشش
داده شوند. برای مثال قبل از هر گونه آزمایش بایستی \lr{Best practice}های آن بخش
پوشش داده شود و سپس به دنبال آزمایش آن‌ها برویم تا از نظر استاندارد پیاده‌سازی
مناسبی داشته باشیم.

برای مثال یک مگا اپلیکیشن به دلیل کمبود زمان در طول توسعه، امکانش نیست که همه
دستورات و شاخه‌هایش آزموده شوند. پس سعی می‌کنیم قسمت‌های تصمیم‌گیری و بخش‌های
حیاتی و مهم نرم‌افزار را به طور کامل آزمایش کنیم تا مشکلی از بابت در دسترس نبود
یا به خطر افتادن نرم‌افزار را تهدید نکند. مثلا فقط حلقه‌ها آزموده شود یا فقط
شروط بررسی شود که چه خروجی دارند. چون بررسی کردیم که احتمال خطا در آن‌ها زیاد‌تر
است.

\subsection{معیار آزمون نرم‌افزار یا \lr{Test Criterion}}

یک مجوعه‌ای از قوانین و فرایند‌هایی که نیازمندی‌های آزمون نرم‌افزار را مشخص
می‌کنند. به عبارتی دیگر راه و عملیاتی که می‌خواهیم برای آزمون نرم‌افزار پیش
بگیریم بایستی براساس معیاری باشد.

\subsection{مورد آزمایش یا \lr{Test Case}}

چه چیزی را می‌خواهیم مورد آزمون قرار دهیم؟ چه ورود‌هایی را برای آن انتخاب
می‌کنیم؟ چه انتظاری از خروجی‌ها داریم؟ (اشاره به \lr{Assertions}).

\subsection{نقاط مرزی آزمایش یا \lr{Test Boundry}}

تمام نقاط مرزی و رعایت استثنا‌های برنامه را بررسی ‌میکنم. برای مثال برنامه‌ای را
توسعه داده‌ایم که مجموع اعداد را حساب کند و تقسیم بر $n$ کند. این برنامه دقیقاً
چه زمانی به زمین می‌خورد؟ چه شرطی وجود دارد که برنامه با ورودی نامناسب به شکست
دچار شود؟

\subsection{معیار‌ها برای آزمون نرم‌افزار مبتنی بر ساختار}

\begin{enumerate}
    \item استفاده از گراف: برای منبع برنامه و طراحی \lr{usecase}ها
    \item استفاده از عبارات منطقی: \lr{(Not $x$ or not $y$) and A and B}
    \item استفاده از ویژگی‌هایی که در دامنه ورودی وجود دارد:
    \begin{enumerate}
        \item \lr{A: {0, 1, > 1}}
        \item \lr{B: {600, 700, 800}}
        \item \lr{C: {swe, cs, isa, infs}}
    \end{enumerate}
    \item \lr{Syntactic structures}: \lr{if (x > y): z = x - y else: z = 2 * x}
\end{enumerate}

گاهی اوقات قبل از هرگونه آزمایش نرم‌افزاری از روش نوشتن عبارات منطقی برای آزمایش
سناریو‌های نرم‌افزاری استفاده می‌شود.

\subsection{منظور از \lr{Bypass} یا کنار گذاشتن}

گاهی در هنگام آزمون بخشی از نرم‌افزار نیاز است که از بررسی برخی قسمت‌ها عملیات
\lr{Bypass} را در پیش گیریم تا سرعت فرایند آزمایش نرم‌افزار افزایش پیدا کند.

\begin{figure}[H]
    \centering
    \begin{forest}
        [Coverage overview for modeling software
            [
                [Graphs
                    [Source]
                    [Specs]
                    [Design]
                    [Usecases]
                ] 
                [Logic
                    [Source]
                    [FSMs]
                    [Specs]
                    [DNF]
                ] 
                [Input space]
                [Syntax
                    [Source]
                    [Models]
                    [Integrating]
                    [Input]
                ]
            ]
        ]
    \end{forest}
\end{figure}

\end{document}