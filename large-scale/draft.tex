وتینگ برای دیتکت کردن فالت مورد استفاده قرار می‌گیرد.

ریپلیکیشن دایورسیتی نداره و تو سیستم‌‌های نرم‌افزاری و سخت افزاری استفاده
می‌شود.

سومی جلسه بعدی: Analytic redundancy

تو این روش ورودی و خروجی و پیاده‌سازی هستش. فانکشن فرق میکنه، وروودی‌ها مختلفه و
خروجی‌ها همین طور. نه تنها تنوع دارند بلکه در ورودی و خروجی و فانکشن هم دارن.
مثال ارتفاع سنج همواپیما

سه روش مختلف گفته،

فشار سنج هوا که متتوجه بشیم

جئومتریک

و یه کار دیگه که تو اسلاید هستش ولی هر کدوم ورودی‌ها مختلف، فانکشن‌های مختلف و
خروجی‌های مختلف دارند اما متخصص میگرده که دنبال صحبت سیستم بگرده.

در حقیقت به خاطر حیاتی بودن مسئله خلبان از sanity checking استفاده می‌کند.
نتیجه‌ای که باید بعد از ۱۵ دقیقه ببینه درسته یا نه؟

روش‌های مختلفی روی availabilty وجود داره. یکی از استراتژی‌هایی که داریم تعدیل
بار کاری است.

exception detection:

تعریف: وقتی که سیستم از اون عملیات نرمالی که انتظار داریم در حال خارج شدن است.

% تمرین: % parameter fence % parameter typeing % timeout

tatic: self-test

وقتی یه مولفه قراره خودش خودشو تست کنه. که ببینه عملیاتش درست بوده یا نه. این
تاکتیک در کنار condition monitoring خوب عمل می‌کنه در حقیقت دائماً داره
رفتار‌های خودشو میبینه. ترکیب با مانیتورینگ. تو سیستم عامل داریم روشنش میکنیم
بوق میزنه که مثلا رم ندارم. توی نرم‌افزار هم میشه چک سام که یه الگوریتمی بررسی
می‌کنه که چطوری یه ورودی به خروجی تبدیل شده تا صحبت خودشو بررسی کنه.

سلف مانیتور و تست میگیم که عامل خارجی برای انجام آن وجود ندارد.

تاکتیک بعدی recover from faults

prepraration and repair آماده سازی و تعمیر

protection grp

گروهی از نودها که از یک یا بیشتر از یک نود اکتیوه و بقیه نود‌ها به عنوان یدک
هستن. یکرسی از منابع در سیستم فعال هستن و دارن کار انجام میدن و یکسری از
سیستم‌ها جنبه بک‌آپ دارن. اگه نودی از کار بیوفته یدکی ها میوتن توی چرخه و تبدیل
به نود‌های اکتیو میشن. به دلیل فالت از دسترس پذیری خارج بشه. یعنی فالت تبدیل به
فیلیور شده. به هر دلیلی اون نوده از دسترسپذیری خارج بشه ما می‌بایست یه جوری
سیستم رو ریکاور کنه.

سه تاکتیک مهم که کاملاً امتحانی هستش:

Active redundancy

hot spare active redundancy

تمام نود‌هایی که توی پروتکشن بودن دریافت کننده و پردازش کننده ورودی‌ها هستن به
صورت موازی هستن. همه کار میکنن تا به خروجی برسن. همه استیتشون با نود‌های اکتیو
سینکه که ورودی بگیرن و پردازش کنن. ۱+۱ ریداندنسی نود اکتیو حتماً یه نود یدکی
بوده. دقیقاً تمام نود دیتا‌های همدیگه رو دارن.

passive redundancy warn spare:

فقط نود‌های اکتیو ما ورودی میگیرن و پردازش انجام میدن. پس نوود‌های یدکی کی
استیتشون اکتیو میشه؟ به صورت دوره‌ای. ۱۲ شب به ۱۲ شب استیتمون رو سینک می‌کنیم از
اکتیو به یدکی. یه نودی یدکی هست که استیتش با اکتیوه هر ۱۲ شب سینک میشه.

spare یا cold spare

اصن نود‌های یدکی اوت او سرویس هستن و اصلاً سینک نیستن با اکتیو‌ها تا زمانی که یه
فالتی تو ایکتیوه فالتی رخ بده که تبدیل به فیلیر بشه. به محض این اتفاق نود‌های
اسپیر عملیاتی اولیه که اکتیوه میتونسته انجام بده رو میتونه انجام بده.

موبایل قدیمی داری که جدیده خراب شده و از قدیمیه که ۲ سال پیش بوده میای استفاده
میکنی که کارت رو راه بندازه و از ورودی‌های که حال حاضر میاد جا نمونی. یعنی تو
اویل ابل هستی ولی کارای اولیه رو میکنه تنها تماس مثلا کار میکنه.

اینا چقدر هزینه بر هستن؟ همونطور که نوشته شده هزینه زیاد به کمه.

Exception handling اول دیتکت میشه بعد هندل میشه.

Rollback: بازگشت به منطقه امن قبلی هستش. استیت خوب شناخته شده قبلیه. همه
تراکنش‌ها خاصیت رول بک ندارن. از حساب بانکی قراره ۵۰ تومن کم بشه به یکی اضافه
بشه سیستم قطع بشه باید پول برگرده به مبدا. طراح مشخص میکنه که نقطه سیف برنامه
کجاست.

Software upgrade: فالت رو میخوایم ریکاور بکنیم آپگریده که بتونیم سیستم رو به
وضعیت مطلوب خودش برسونیم.

retry: مهم‌ترین استراتژی تاکتیک ریکاوری فرام فالته. جایی که فیلیور رخ داده رو
قطع میکنه و دوباره اجرا میکنه که به موفقیت برسه. یبار دیگه ریترای کنی ممکنه سرور
تو رو به یه سرور خلوت‌تر هدایت کنه. خیلی شلوغه آموزشیار اینا تاکتیکه.

Ignore faulty behavior: نسبت به رفتار‌هایی که به نظر فالتی میرسه ایگنور بشه.
سیستم نسبت به پیام‌هایی که از یه منبع مشکوک میاد هیچ واکنشی نشون نده. منبع مشکوک
یعنی منبعی که توی سیستم ناشناخته است و احتمالاً شما رو به سمت فیلیور شدن سیستم
می‌برد. خارج از حوزه تعریفش باشه.

عموماً یه تاکتیک استفاده نمیشود بلکه مجموعه‌ای از تاکتیک‌ّها مورد استفاده قرار
می‌یگرد. سیستم هر موقع به اون آستانه رسید باید یه استراتژی رو طراحی کنیم که
سیستم رو از اون شلوغی که رخ داده خالی کنیم. آستانه‌ها کاملاً به مشاهده مهندس از
سیستم بستگی داره. Single criteria عمل نمی‌کنیم هیچ وقت.

degradation تنزل:
سینک آشپزخونه خراب میشه خونه رو تعطیل نمیکنیم و میگیم که اونجا خرابه استفاده
نکنین. تنزل انجام میدیم توی سیستم ولی سیستم رو اوت او سرویس نمی‌کنیم. مثل جریان
جیمیل که یه حالتی داشت می‌برد ما رو به حالت ساده که بتونیم کارایی اولیمون رو
استفاده کنیم.

skeleting restart:

reconfiguration: اساین کردن وظایف به منابع باقی مانده. reassignment وظایف میاد
به نود‌ها اساین میشه که در حقیقت کارشون اون نبوده چرا میشه چون که اون نود‌های
اصلی دیگه نیستن و باید این نود‌هایی که باقی مونده کار رو انجام بدن. هر کدوم از
نود‌های ریاساین شده حداقل کار‌ها رو میکنن.

\subsection{reintroduction}

shadow: کامپوننتی که از دسترسی ما خارج شده یک بازه زمانی در حالت شدو بمونه.
ورود‌ها از به این نود هم داده بشه که ببینم اون نود اکتیو به اون خروجی رسیده اینم
رسیده یا نه. بازه زمانی رو طراح مشخص میکنه. برای سیستم‌هایی که critical هستش که
در لحظه سیستم باید پاسخ درست رو نشون بده. هزینه بره قطعاً چون دو تا سیستم باید
همزمان کار کنن.

state resync: اگر اکتیو و پسیو باشه باشه باید ریسینک بشه کولد اسپیر که اصلاً
سینک نمیشده که بخواد ریسینک بشه. وابستگی به مانیتورینگ داره که تمامی اطلات بگه.
از این تاکتیک باید استفاده بشه.

NSF or Non Stop Forwarding: امتحانیه و جز اون سوالست. اگر تابع یه سیستمی رو
بخوایم بررسی کنیم که الگوریتم رو ورودی‌ها فعال میکنن میشه فانکشن سیستم. فرض شود
که روتری داریم سوپروایزور یا الگوریتمش درست کار نمی‌کن. به هر دلیلی الگوریتم
مسیریابی فیلد بشه. این الگوریتم رو با همون جدول هماسگی بتونه بازم مسیریابی کنه.
معضلات اینه که باید کانکتیویتی از بین نره. اصلاً نباید اتصالات از بین بره نود
خاموش شد اینا باید بتونه مسیر جدید رو پیدا کنه. دو تا الگوریتم هستن 

escalaling restart: بالابرده میشه اضافه کردن. مثال داره، شما عموماً توسیستم با
سلسله مراتب مواجه هستیم که پدر فرزندی هستند. طراح تصمیم میگیره که وقتی یه سیستمی
آبرومندانه تنزول کرده باید سلسله مراتبی بالا بیاد که کامپوننت به کامپوننت بوده و
برای بالا اومدنش هم کامپوننت هستش. اول بچه‌ها بعد پدر اول بچه‌ها بعد پدر.
graceful degradation.

\subsection{Prevent faults}

Removal from service: با software rejuvenation جوان سازی نرم‌افزار ارتباط دارد.
یک مفهنومی به اسم ممولیک وجود داشت، کامپوننت‌هایی رو می‌بینی که سیستم رو به عدم
دسترسی می‌رسونن باید قبل از اینکه فالته اتفاق بیوفته باید ازش جلوگیری بشه
وبرگرده توی مدار.

transactions

بحثی وجود داره که مسابقه بر سر منابع. که این تاکتیه که تمرینه این مشکل رو حل
میکنه.
TODO: جلسه بعد

predictive model: مانیتورینگ استیت سیستم باید باشه. مدل‌های پیشبینی. اگر ما این
تاکتیک رو انتهاب کنیم می‌توینم تصمیم‌های بهتری نسبت به سیستم بگیریم. نرخ ورود
دیتا درخواستی که زیاد میشه رو داری از مانیتور + پریدیکشن مشاهده میکنی. طول صف رو
میدونی و نسبت به اون عمل میکنی. تصمیم‌گیری‌های مهم رو می‌بریم تو سیستمی که از
پریدیکت استفاده میکنیم.

exception prevention:

increate competence set: افزایش مجموعه شایستگی‌ها. کامپوننت‌ها طوری دیزاین بشه
که مجموعه شاسیتگیشون از حوزه رفتاری بیشتر شده باشه. فرض کنیم که کامپوننت داریم
که میخوایم بهش دسترسی پیدا کنیم. در خواست رو به کامپوننت میدیم که به هر دلیلی
درخواست اکسپت نمیشه. مثلا درخواست قابل انجام نبود و دسترسی کنسل شد. یه خورده صبر
کن و یه ترای بکنه که این درخواست رو داشته باشه. کامپوننته نرخ عدم دسترس پذیری
کمتر بود دیگه تو یه فرصتی اومده توی جریان.

یعنی کامپوننت داشته باشیم که مثلا ۲ ثانیه دیگه دوباره ترای کنه دسترسی براش
برقرار بشه.

اکتیو پسینگ و اسپیر و وتینگ کاملاً تو امتحانات هستش.

دو تا تاکیتک راز reinteroduction مثلا میگه که توضیح بدین. نیازی نیست نام ببریم
فقط اینکه قشنگ بگیم چی به چیه.

یه سوال تحلیلیه که بین ۴ تا ۴.۵ نمره داره. که ویژگی کیفی مورد نظر با ذکر دلیل
چرا این تاکتیک به نظرت اوکیه مثلا مانیتورینگ چرا انتخاب شده?