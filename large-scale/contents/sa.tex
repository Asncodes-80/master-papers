\section{معماری مقیاس بزرگ نرم‌افزار}

\subsection{معماری نرم‌افزار چیست؟}

معماری نرم‌افزار یک تعریف واحد ندارد. معماری نرم‌افزار یک برنامه یا یک سیستم
محاسباتی می‌باشد. یک ساختار یا مجموعه ساختار‌هایی است از سیستم مورد نظر ما که
متشکل از المان‌های کامپیوتری است و نمود خارجی یک چیز (المان) می‌باشد و ارتباطات
بین آن‌ها را در بر می‌گیرد. هیچ‌گاه نمی‌توان نرم‌افزاری نوشت که معماری نرم‌افزار
نداشته باشد. برای مثال از معماری \lr{MVC} در نرم‌افزار خود استفاده کرده‌ایم.
نرم‌افزاری وجود ندارد که معماری نداشته باشد. اگر بگوییم نرم‌افزاری معماری ندارد
در حقیقت علم معماری به کار گرفته شده را نمی‌دانیم که آن را بی‌معماری می‌نامیم.
برای مثال معماری کلاینت سرور که براساس نیازمندی‌های نرم‌افزاری بیان می‌شود که چه
بخش‌هایی سمت سرور باشد چه‌ بخش‌هایی سمت کلاینت.

\subsection{معمار نرم‌افزار کیست؟}

معمار نرم‌افزار شخصی مدبر است که تجربه تخصصی آن در حوزه‌ای مشخص بیشتر از ۱۰ سال
است که تسلط کافی در آن سیستم مشخص دارد و از ابتدا تا انتهای پروژه با فرایند
توسعه و توسعه‌دهندگان همراه است.

\subsection{المان‌ها}

بخش‌های یک سیستم نرم‌افزاری را گویند برای مثال یک نرم‌افزار واحد مانیتورینگ،
واحد زمان‌بندی، واحد بررسی درخواست‌ها و غیره را دارد.

\subsection{\lr{External Feasible Properties}}

آن بخش چه وظیفه‌ای را باید انجام دهد و آن بخش آن وظیفه را در حال انجام است یا
خیر؟ جزئیات مربوط به المان‌های درگیر در بخش معماری در \lr{External Feasible
Properties} مطرح نمی‌شود.

\subsection{تفاوت کامپوننت و المان}

وقتی در مورد کامپوننت می‌گوییم در حقیقت چیزی است که می‌خواهیم آن را پیاده‌سازی
کنیم. المان کامپوننتی است که قسمت اجرایی را برای آن در نظر نگرفته‌ایم.

\subsection{بخش‌هایی که معماری نرم‌افزار باید پوشش دهد}

\begin{enumerate}
    \item المان‌هایی که در سیستم قرار است استفاده شود را مشخص می‌کند.
    \item نمود خارجی المان‌های سیستم مورد نظر را مشخص می‌کند و تعیین می‌کند هر
    المانی در سیستم چه وظیفه‌ای را انجام دهد.
    \item ارتباطات بین المان‌ها را به روشنی مشخص می‌کند.
\end{enumerate}

در کنار تمامی موارد بالا، بخش‌هایی که یک معماری نرم‌افزار پوشش نمی‌دهد شامل ذات
المان‌ها می‌باشد.

\subsection{قابلیت اطمینان یا \lr{Reliability}}

یک سیستمی که در زمان مشخص درست کار کند به شرطی که در زمان $T - x$ درست کار کرده
باشد.

\subsection{قابلیت استفاده یا \lr{Useability}}

سیستمی که کارآمد باشد برای آن دسته از افرادی که سیستم را حاضر و آماده کرده‌ایم.
به گونه‌ای که با ظاهر مناسب کار کردن با آن نیز آسان باشد.

\subsection{ارائه سریع محصول یا \lr{Short time to market}}

قابلیت یا \lr{Feature} مجموعه‌ای از توابع نرم‌افزاری است که وقتی در بازار ارائه
می‌شود، واقعاً کار می‌کند. 

\subsubsection*{نکات}

\begin{itemize}
    \item تا آنجایی که می‌شود هزینه‌ها را باید کاهش بدهیم و بیشترین هزینه‌ها را
    ما در بخش توسعه نرم‌افزار خواهیم داشت. همیشه باید کارمندان را مشغول توسعه
    نگهداریم تا باعث از دست رفتن هزینه‌ها نشود.
    \item مشکل معمار آن است که حجم زیادی از نیازمندی‌های نرم‌افزاری را در حال
    بررسی است که نسبت به هم در تضاد هستند.
    \item بخشی از وظایف اصلی معماری نرم‌افزار مشخص کردن استک‌های نرم‌افزاری
    می‌باشد. بخش دیگری از آن این است که بررسی کند این موارد توسط تیم اجرا و
    استفاده می‌شود یا خیر (\lr{Follow up})
\end{itemize}

\subsection{تفاوت معماری سازمانی و معماری نرم‌افزار}

معماری سازمانی و معماری نرم‌افزار با یکدیگر متفاوت است. در معماری سازمانی، چارت
سازمانی آن مشخص‌کننده محدوده و کلیت هر قسمت آن سازمان می‌باشد.

% \lr{Mobile Adhoc Network}

% شبکه‌های موردی متحرک

% یک شبکه‌ای است فاقد زیرساخت. بیشتر در مناطق جنگی و \lr{Real-time} مورد استفاده
% قرار می‌گیرد که بتوانیم در حال حاضر یک شبکه را آماده کنیم که سربازان با یکدیگر
% ارتباط بگیرند به گونه‌ای که \lr{Mobility} بیان می‌کند که شبکه را بایستی با
% زیرساخت مناسب ایجاد کند.

% یک پیام «سلام» ارسال می‌کند و منتظر دریافت \lr{ACK} می‌باشد و بعد از آن سعی
% می‌کند که ارتباط را حفظ کند تا آن کانال ارتباطی بین سربازان برقرار باشد.

\subsection{جزئیات فعالیت‌های معماری نرم‌افزار}

\subsubsection{ساخت \lr{Business case} برای سیستم}

\subsubsection*{یادآوری \lr{Business plan}}
بیزینس پلن سندی است که چهارچوب سیستم ما را در بر می‌گیرد و آن را نسبت به سیستم
مشابه مقایسه می‌کند و آن را به چالش می‌کشد. نسبت به هر چالشی که در سیستم ما وجود
دارد بایستی پاسخی مطرح شده باشد.

سند \lr{Business case} سندی از جنس مالی است که در آن برآورد هزینه و توجیهات
اقتصادی بیان شده است. در این سند، درگیر بودن نیرو‌ها بررسی می‌شود و در نهایت
توجیهات‌ اقتصادی را از نظر کاهش هزینه‌ها مطرح می‌کند. برای مثال ممکن است بیشتر
اوقات بهره‌وری سیستم را افزایش داده باشیم که نسبت به این افزایش باید توجیهی وجود
داشته باشد.

از ابتدا تا انتهای پروژه دائماً در حال تخمین قیمت پروژه به عنوان معمار نرم‌افزار
هستیم که در آن هزینه‌ای را مطرح می‌کنیم که بررسی کرده‌ایم در توسعه نرم‌افزار
نیاز خواهد شد. در این حین اگر هزینه توسعه بیشتر شود باعث ضرر ما و اگر کمتر شود
باعث سود ما خواهد شد. پس به همین دلیل سعی می‌کنیم سند \lr{Business case} را از
ابتدا تا انتهای فرایند پروژه توسعه دهیم و توجیه اقتصادی به روزی در آن داشته
باشیم که موجب ضرر از سمت پیمانکار نشود.

\subsubsection*{نقطه سر به سر یا \lr{Break event point}}

وضعیتی است که در آن هزینه‌هایی که ما برآورد کرده‌ایم در بازه زمانی مشخص، برابر
با صفر شده است. برای مثال اگر مبلغ ۵۰۰ میلیون تومان را به عنوان هزینه نرم‌افزار
محاسبه کرده باشیم و طی یک سال دیگر سازمان دقیقاً همان مبلغ را بدون کاهش یا
افزایش پرداخت می‌کند این وضعیت نقطه سر به سر خواهد شد. زمان نقطه سر به سر
معمولاً در بازه ۲ تا ۵ سال تعریف می‌شود که در واقعیت زمان خیلی طولانی برای تخمین
هزینه توسعه نرم‌افزار محسوب می‌شود.

\subsubsection{فهمیدن نیازمندی‌های پروژه}

نیازمندی‌ها تنها متغیر ثابت هستند. همانطور که پیش‌تر اشاره شد
\lr{non-functional}ها در قالب سند معماری نرم‌افزار دیده می‌شوند. همچنین اگر
نیازمندی \lr{functional} وجود نداشته باشد \lr{non-function}ها معنایی ندارند.
برای مثال می‌گوییم که نرم‌افزارمان بایستی امن باشد، یعنی \lr{Usecase diagram}
داریم که ازای آن نیازمندی \lr{non-function} تعریف کرده‌ایم.

نکته مهم آن است که مهمار نرم‌افزار تنها نیازمندی‌های جاری را در نظر نمی‌گیرد
بلکه نیازمندی‌های آتی را هم در سند پیشبینی می‌کند تا بتواند یک جریان را کامل کند
و به نوعی \lr{Proof of concept} داشته باشد.

\subsubsection{ایجاد یا انتخاب یک معماری نرم‌افزار}

معمار نرم‌افزار معمولاً یا یک معماری را انتخاب می‌کند یا آن را از نو می‌سازد.
ممکن است در تز‌های آکادمیک معماری جدیدی را ایجاد کرده باشیم زیرا ممکن است صورت
مسئله‌های جدیدی پدید آمده باشند یا نیازمندی‌های \lr{non-function} جدیدی یافت شده
باشد. در حالت کلی معماری‌ها را یا باید بهینه‌سازی کنیم یا اجرا و در پروژه
نرم‌افزاری پیاده کنیم.

\subsubsection{دنبال کردن معماری یا \lr{Communicating the architecture}}

چیزی که در معماری نرم‌افزار بیان شده است را دنبال کنیم و بررسی کنیم که تمام آن
فرایند‌های مهندسی توسعه نرم‌افزار را توسعه‌دهنده‌ای دنبال می‌کند یا خیر. بیان
این مسئله طرف معمار و اجرای آن در طرفی دیگر است. خیلی با بخش \lr{Implementing
based on the architecture} ارتباط دارد.

\subsubsection{بررسی و ارزیابی معماری}

نکته مهم آن است که در حوزه معماری نرم‌افزار چیزی به نام شبیه‌سازی نداریم چرا که
قدم ابتدایی هر پروژه‌ای تعیین معماری آن است. اینکه از ما سوال شود که معماری
نرم‌افزارتان را با چه شبیه‌سازی اجرا کردین یا با چه فاکتور‌های شبیه‌سازی آن را
ارزیابی کرده‌اید، بحث کاملاً غلطی می‌باشد. مقایسه بین الگوریتم‌ها امکان‌پذیر
می‌باشد زیرا داریم شبیه‌سازی ورکلود‌ها را انجام می‌دهیم.

در این خصوص روشی را داریم به نام \lr{ATAM} که ارزیابی معماری نرم‌افزار را
می‌توان از طریق آن انجام داد. یک استاندارد مشابه با \lr{ISO} می‌ماند که
نیازمندی‌های \lr{non-functional} را در نظر می‌گیرد. یک تیم مستقل با آن همراه است
که بررسی کند ما از راه درستی استفاده کرده‌ایم یا خیر. در نهایت به ما نشان می‌دهد
که نسبت به آن سناریو می‌توانیم این معماری را پوشش دهیم یا خیر.

برای بررسی و ارزیابی معماری راه‌های مختلفی وجود دارد:

\begin{enumerate}
    \item مدل‌سازی صوری، فرمال و رسمی: برای اینکه ثابت کنیم چیزی که داریم
    می‌نویسم قابل تایید است و درست می‌باشد. به دلیل آن که ریاضی هستند می‌توانند
    مفید و رویکردی مناسب باشند.
    \item استفاده از \lr{ADL: Architecture Definition Language}
    \item استفاده از \lr{Prototype}ها: اگر یک سیستم کوچک درست کنیم که به
    صورت صحیح کار کند می‌تواند نشان دهنده آن باشد که سیستم اگر بزرگتر شود هم
    صحیح کار خواهد کرد.
    \item ۸۰ درصد نیازمندی‌ها و دامنه‌های مسئله با نرم‌افزاری که در حال کار است
    که با این معماری انطباق دارد پس قطعاً معماری با کار‌های آینده ما نیز منطبق
    خواهد بود.
\end{enumerate}

\subsubsection*{نکته}

دامنه مسئله مثل دامنه سیستم‌های مالی، دامنه سیستم‌های آموزشی و غیره یک تعریف
مسئله مخصوص و واحد دارد که در سیستم‌های گوناگون مشابه یکدیگر هستند و دقیقاً
نیازمندی‌های آن‌ها نیز مشابه هستند. اگر یک سیستم مشابه را پیدا کردیم، معماری
انتخابی ما می‌تواند با سیستم مشابه نیز کار کند.

\subsubsection{پیاده‌سازی مبتنی بر معماری}

بررسی اینکه آیا تمام فرایند‌هایی که در فاز‌های توسعه نرم‌افزار شروع می‌شود با
بیانات و نقشه‌راه معمار نرم‌افزار مطابقت دارد یا خیر؟

\subsubsection{اطمینان از انطباق نسبت به یک معماری}

در این بخش بررسی می‌کنیم که فرایند‌ها تماماً تابعی از معماری هستند یا خیر؟ در
انتهای کار، تمام‌ اسناد را در کنار هم قرار می‌دهیم و به تطبیق اسناد با سند
معماری می‌پردازیم. برای مثال تمام \lr{Usecase diagram}ها مطابق با سند معمعاری
\lr{Usecase}ها بوده‌اند؟ طبق استاندارد طراحی شده‌اند؟ اگر هر کدام مطابقت نداشت
بایستی سریعاً اصلاح شود تا از ایجاد هزینه‌های آینده جلوگیری به عمل آورد. ما
بایستی مطمئن باشیم که تمام اسنادی که به معمار نرم‌افزار تحویل می‌دهیم مطابق با
سند معماری باشد که شامل چندین بخش خواهد شد.

\subsection{چه چیزی یک معماری خوب را تحویل می‌دهد؟}

هیچ چیز ذاتاً خوب یا بد نیست بلکه واسبتگی بسیار زیادی به کاربرد آن در سیستم مورد
نظر دارد. معماری کنترل دمای یک نیروگاه تولید برق را نمی‌توان در کنترل دمای خانه
استفاده کرد چون استفاده نادرست و نا به جایی بوده است. ذاتاً نمی‌توانیم بگوییم که
کدام معماری خوب است کدام معماری بد بلکه انتخاب ما نسبت به سیستم خوب و بد دارد.

معماری قابل ارزیابی است پس باید براساس اهدافی که داریم فرایند ارزیابی را انجام
دهیم تا در نهایت ببینیم که این ارزیابی چقدر می‌تواند معماری را با اهداف ما
\lr{Match} کند. برای مثال ممکن نیست که یک سامانه‌ای که امنیت ندارد را الهام
بگیریم برای سامانه‌ای که یکی از اهداف اصلی آن امنیت است.

نمودار زیر را از معماری سطح بالای \lr{ATM} را در نظر بگیرید:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{images/bad-arch-of-atm.drawio.pdf}
    \caption{نمایش معماری سطح بالا دستگاه \lr{ATM}}
    \label{fig:atmDiagram}
\end{figure}

شکل شماره \ref{fig:atmDiagram} ساختار کلی از دستگاه \lr{ATM} را نمایش می‌دهد.
درست است که در مطالب بالاتر گفتیم که معماری یک چکیده از ساختار سیستم می‌باشد اما
در این نمودار ارتباطات بین المان‌ها کاملاً همراه با ابهام می‌باشد و تمام معماری
دستگاه \lr{ATM} را پوشش نمی‌دهد. در این نمودار ذات المان‌ها مشخص نیست. برای مثال
مشخص نیست که واحد \lr{Card interface} ممکن است هم کارت را دریافت کند هم اعتبار
کارت ورودی را بسنجد؟ پس می‌توان گفت وظیفه المان \lr{Card interface} در این
نمودار اصلاً مشخص نیست و در این نمودار دقیقاً ماهیت ارتباطات بین المان‌ها مشخص
نیست. همچنین لایه‌بندی در این نمودار به صورت واضح کشیده نشده است. در لایه‌بندی
همواره منطق وجود دارد مانند لایه‌بندی استاندارد \lr{OSI} که جانمایی المان‌ها در
این نمودار کامل کشیده نشده است. برای مثال بحث امنیت و کارایی و تعامل‌پذیری اصلاً
وجود ندارد. لایه‌بندی یک معماری تماماً توسط معمار نرم‌افزار مشخص خواهد شد.

\subsection{تفاوت \lr{Fault} با \lr{Failure}}

\lr{Fault} یعنی یک نقضی بالقوه در سیستم وجود دارد تا زمانی که سیستم بدون مشکل
کار کند آن نقض خودش را نمایان نمی‌کند اما در شرایط خاصی ممکن است برنامه به این
\lr{Falut} برخورد کند و بالفعل موجب از کار افتادن نرم‌افزار شود. در حقیقت بعد از
برخورد نرم‌افزار با \lr{Fault} پدیده‌ای به نام \lr{Failure} رخ می‌دهد. در حقیقت
\lr{Fault} در نرم‌افزار وجود داشته است که در شرایط خاص با ورودی خاص کاربر برنامه
با شکست یا \lr{Failure} رو به رو می‌شود و باعث کار نکردن درست نرم‌افزار خواهد
شد.

همواره \lr{Fault} از سمت طراحی نرم‌افزار همراه خواهد بود زیرا بایستی در اسناد
طراحی به آن نگاه مهندسی شود. زمانی که پیاده‌سازی می‌شود اگر در شرایط آزمون
بتوانیم آن \lr{Fault}ها را شناسایی کنیم و آن‌ها را رفع کنیم سیستم را از
\lr{Failure}های آینده نجات خواهیم داد.

نکته: \lr{Fault} موجب \lr{Failure} می‌شود.

اگر ما یک حافظه \lr{USB} داشته باشیم و در هنگام انتقال اطلاعات ناگهانی فلش را از
سیستم خارج کنیم، در حقیقت نه \lr{Fault} نه \lr{Failure} و نه \lr{Error} رخ داده
است. بلکه سیستم توسط عامل خارجی دستکاری شده است. اگر \lr{Fault} در سیستم داشته
باشیم بایستی توانایی هندل کردن آن را در نرم‌افزار داشته باشیم.

\subsection*{نکات}

\begin{itemize}
    \item معماری نرم‌افزار المان‌های نرم‌افزاری را مشخص می‌کند.
    \item \lr{Mapping} تسک‌ها به منبع مشخص تعریف زمانبندی است.
    \item تسک‌ها در حقیقت کار‌هایی هستند که در سیستم تعریف می‌شوند.
    \item ورکفلو مجموعه‌ای از تسک‌های وابسته به هم می‌باشد.
    \item \lr{Bag of tasks} عموماً وابستگی ندارند.
    \item \lr{Multiple workflow scheduling} به معنای زمانبندی چند ورکفلو
    می‌باشد.
    \item همیشه یک زمانبندی بهینه نداریم بلکه باید در شرایط مناسب از زمانبندی
    مناسبی استفاده کنیم.
    \item در هنگام مهندسی نرم‌افزار باید تا آنجایی که می‌شود نرخ موفقیت یک تسک
    را بالا ببریم.
\end{itemize}

\subsection{منابع همگن و ناهمگن}

\begin{itemize}
    \item منابع همگن به منابعی گفته می‌شود که همه المان‌ها در آن دقیقاً یک چیز
    هستند یا به عبارتی همه منابع به صورت \lr{Clone} از یکدیگر هستند. برای مثال
    همه از یک سخت‌افزار استفاده می‌کنیم بدون هیچ تفاوتی.
    \item منابع ناهمگن به متفاوت بودن سیستم‌ها نسبت به یکدیگر اشاره دارد.
\end{itemize}

\subsection{تعریفی دیگر برای معماری نرم‌افزار}

یک معماری نرم‌افزار مجموعه‌ای از کامپوننت‌ها، ارتباطات بین آن‌ها و قید و
بند‌هایی است که در سند مناسب تعریف می‌شود. در حقیقت در اینجا تعریف مورد نظر
تعریف \lr{3C} می‌باشد:

\begin{enumerate}
    \item \lr{Components}
    \item \lr{Connectors}
    \item \lr{Constraints}
\end{enumerate}

در پروژه‌های حقیقی خواهیم داشت:

چند تا کلاینت داریم که توسط چند تا سرور به صورت متناسب سرویس دریافت می‌کنند. هر
کدام از سرویس‌ها نیز برای ارتباط با یکدیگر و ارسال داده‌های اصلی مانند توکن
احراز هویت کاربر، در تاپیکی مشخص در \lr{Broker} اطلاعات را ارسال می‌کنند و برای
حفظ امنیت هم سرور‌ها در بستر پروتکل \lr{Https} مستقر شده‌اند.

\subsection{مفاهیم مفید و کارآمد معماری نرم‌افزار}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/box_and_arrow_sa.drawio.pdf}
    \caption{ارتباط بین مدل‌های مرجع، الگو‌های مربوط به معماری، معماری‌های مرجع
    و معماری‌های نرم‌افزار}
    \label{fig:saStages}
\end{figure}

\subsubsection{\lr{Architectural patterns} یا الگو‌های معماری}

الگو راه‌حلی برای خانواده‌ای از مشکلات می‌باشد. در حقیقت به الگو ممکن است
\lr{Style} هم گفته شود.

وابسته به دامنه کاری نمی‌باشد؛ وقتی در مورد الگوی معماری کلاینت سرور صحبت
می‌کنیم می‌تواند شامل دامنه‌های مختلفی مانند نانوایی تا سیستم‌های بزرگ‌تر شود.

برای مثالی دیگر می‌توان به الگوی \lr{Black board} اشاره کرد که هر آن چیزی که
قرار است خوانده و نوشته شود در این الگو مشخص می‌گردد. از مهم‌ترین کاربرد‌های این
الگو نیز می‌توان به حافظه‌های مشترک در معماری کامپیوتر نیز اشاره کرد.

\subsubsection{\lr{Layering pattern} یا الگو لایه‌بندی کردن}

در روش لایه‌بندی کردن، هر لایه نسبت به لایه‌های دیگر کاملاً متمایز است و زمانی
که نیازمند ایجاد لایه‌ای جدید مانند امنیت هستیم می‌توانیم از این الگو استفاده
کنیم.

برای مثال، لایه‌بندی برای مسئولین یک دانشگاه را در نظر بگیرید، مسئولینی که سمتی
بالایی دارند عموماً در طبقات بالاتر ساختمان دانشگاهی هستند.

\subsubsection{کاربرد الگو}

الگو‌ها روی ویژگی‌های کیفی کار می‌کنند و می‌توان گفت الگو‌ها به طور مستقیم روی
ویژگی‌های کیفی \footnote{\lr{Quality properties}} ارتباط دارند. براساس ویژگی‌های
کیفی، الگو‌ها را انتخاب می‌کنیم. برخی عملکرد مناسب را پوشش می‌دهند و برخی دیگر
امنیت و دسترس‌پذیری بالا را. اگر بخواهیم ویژگی کیفی جدیدی را ایجاد کنیم بایستی
الگو مورد نظر را تغییر دهیم. الگو‌ها عموماً به صورت ترکیبی استفاده می‌شوند.

\begin{itemize}
    \item الگو‌ها تحلیل فضای مسئله را مشخص می‌کنند. در تحلیل سیستم، سیستم را به
    طور واضح خواهیم شناخت. ارتباطات آن را بیشتر می‌توان درک کرد و مشکلی را متوجه
    شد که برای پاسخ به آن در طراحی وارد عمل می‌شویم. تمام نمودار‌ها و
    نیازمندی‌ها در این مرحله مطرح می‌شوند.
    \item طراحی راه‌حل مورد نیاز برای فضای مسئله را بررسی می‌کند. ما نمی‌توانیم
    در فاز طراحی بپرسیم که آیا این کامپوننت با کامپوننت دیگر بایستی ارتباط داشته
    باشد زیرا در فاز فضای مسئله تمام این موارد و ارتباطات بایستی مشخص می‌شد.
\end{itemize}

\subsubsection*{سوال (کنکوری)}

\begin{enumerate}
    \item آیا هر معماری یک طراحی است؟
    \item آیا هر طراحی یک معماری است؟
\end{enumerate}

\subsubsection*{پاسخ سوال اول}

بله هر معماری شامل طراحی می‌باشد که در آن به صورت صریح و مشخص به همراه جزئیات
تمام سیستم مورد بررسی قرار گرفته است و می‌توان از آن‌ها برای پیاده‌سازی محصول
نرم‌افزاری مورد نظر استفاده کرد. همانطور که پیش‌تر گفته شد هر معماری شامل تجرید
کلی از یک سیستم است اما در طراحی ما سطح تجرید را به شدت کم می‌کنیم و در آن وضعیت
المان‌ها، روابط و نمود خارجی آن‌ها را به صورت صریح به همراه جزئیات مطرح می‌کنیم.
پس در هر معماری می‌تواند طراحی وجود داشته باشد.

\subsubsection*{پاسخ به سوال دوم}

خیر هر طراحی یک معماری محسوب نمی‌شود زیرا طراحی به صورت دقیق و با جزئیات کل
سیستم را مورد بررسی قرار می‌دهد اما در معماری سطح تجرید بالا می‌باشد و ما قادر
نخواهیم بود که در آن جزئیات را مطرح کنیم.

\begin{itemize}
    \item گام اول طراحی معماری می‌باشد.
    \item در \lr{RUP} فرایند تشریح اولین قدم می‌باشد.
    \item سند معماری باید به صورت نهایی شده باشد تا بتوان وارد فاز طراحی شد.
    \item سند نیازمندی‌ها نیز باید ۸۰ درصد نیاز‌ها را برآورد و نهایی کرده باشد
    تا بتوان وارد فاز طراحی شد.
\end{itemize}

\subsubsection{\lr{Reference models} یا مدل مرجع}

مدل مرجع تقسیم وظیفه‌مندی یک سیستم همراه با جریان داده آن قسمت می‌باشد.

\begin{itemize}
    \item در مدل مرجع \lr{OSI} هر لایه وظیفه آن به صورت دقیق مطرح شده است.
    \item در امور مالی هیچ وقت انتخاب واحد را انجام نمی‌دهیم.
    \item واحد زمان‌بندی یک \lr{Borker} دارد، یک واحد \lr{Score} و یا واحد
    \lr{Periority}. به طور کل یک پکیج است که تمام موارد گفته شده در آن موجود
    می‌باشد.
\end{itemize}

\subsubsection{\lr{Reference architecture} یا معماری مرجع}

همانطور که از نامش پیداست مانند الگو‌های معماری، اگر بخواهیم سیستم را راه‌اندازی
کنیم که در دامنه آن دقیقاً همان سیستم به شکل دیگر وجود داشته باشد می‌توانیم از
آن سیستم به عنوان مرجع معماری نرم‌افزار خود استفاده کنیم. برای مثال اگر بخواهیم
یک نرم‌افزار دانشگاهی جهت مدیریت دانشجویان بسازیم می‌توانیم از مدل‌های مرجع
دانشگاه‌های دیگر نیز استفاده کنیم.

\subsection*{نکات}

\begin{enumerate}
    \item گام اول طراحی، معماری نیازمندی‌های سطح بالای سیستم است که در همان لحظه
    باید متوجه شویم.
    \item روش تخمین هزینه و زمان انجام کار در معماری مشخص می‌شود.
    \begin{enumerate}
        \item استفاده از روش \lr{COCOMO}: روش کوکومو که از سرکلمات
        \lr{Constructive Cost Model} گرفته شده است در آن میزان تلاش، زمان صرف
        شده و هزینه‌های مربوط به پروژه نرم‌افزاری به صورت کامل برآورد شده است.
        معیار‌های مهم در کوکومو شامل، اندازه پروژه، پیچیدگی انجام پروژه، تجربه
        اعضای تیم و محیط توسعه می‌باشد \cite{COCOMO}.
        \item استفاده از روش \lr{LoC} یا \lr{Line of Code}: این روش هیچ خلاقیتی
        در تخمین هزینه‌ها ندارد ولی یکی از روش‌های اولیه و مبتدیانه برآورد هزینه
        یک پروژه نرم‌افزار براساس تعداد خط کد‌های زده شده می‌باشد.
    \end{enumerate}
    \item در برخی پروژه‌ها گاهی معمار و طراح می‌توانند یک نفر باشند.
    \item یک معمار دائماً ویژگی‌های کیفی را در طراحی و پیاده‌سازی مد نظر دارد.
    \item از یک معماری نرم‌افزاری می‌توانیم اسفاده مجدد کنیم به شرط آن که
    ویژگی‌های کیفی یکسانی داشته باشند.
    \item معماری یک دید ایستا نمی‌باشد.
\end{enumerate}

\subsection{دلیل اهمیت معماری چیست؟}

\begin{enumerate}
    \item معماری نرم‌افزار ارتباطات بین ذینفعان را مشخص می‌کند که هر کدام از
    آن‌ها مجموعه‌ای از نیازمندی‌ها را دارد که حتی بین نیازمندی هر ذینفعی تضادی
    نیز وجود دارد. معماری نرم‌افزار تصمیم اولیه طراحی می‌باشد و تمام ارتباطات را
    به صورت کامل پوشش می‌دهد.
    \item تصمیمات اولیه طراحی: ابتدایی‌ترین نقطه‌ای که می‌توان تصمیم را در آن
    گرفت نیز تحلیل و بررسی می‌شود. \lr{Early design decisions}:
    \begin{enumerate}
        \item معمار قید و بند‌ها را در طراحی تعریف می‌کند.
        \item معمار ساختار سازمانی را به ما دیکته می‌کند.
        \item معمار تسلط کاملی روی ویژگی‌های کیفی دارد.
        \item معمار می‌تواند نیاز‌های آتی را پیشبینی کند.
        \item معمار می‌تواند به آسانی تغییرات را مدیریت کند.
        \item معمار می‌تواند در کامل کردن پروتوتایپ کمک کند.
        \item معمار کسی است که با دقت بیشتر می‌تواند هزینه‌ها و زمانبندی را
        برآورد کند.
    \end{enumerate}
    \item تجرید قابل انتقال از یک سیستم: از سیستم‌های مقیاس بزرگ می‌توان بار‌ها
    استفاده کرد (به عنوان \lr{Reference architecture}). معماری نرم‌افزار یک مدل
    قابل فهم و نسبتاً ساده ایجاد می‌کند تا به وسیله آن مشخص شود چگونه یک سیستم
    ساخته می‌شود و چگونه عناصر آن با یکدیگر کار می‌کنند.
    \item نه فقط کد می‌تواند قابل استفاده مجدد باشد بلکه حتی نیازمندی‌های موجود
    در معماری در مراحل اولیه نیز می‌تواند قابل استفاده مجدد باشد.
    \item عموماً معماری، خط تولید یک معماری مشترک را به اشتراک می‌گذارد.
\end{enumerate}

% در آزمون جامع دکتری پرسش فراوانی دارد.
\subsection{تفاوت معماری سیستم و معماری نرم‌افزار}

در معماری یک نرم‌افزار ملاحضات سیستم نادیده گرفته می‌شود. برای مثال اگر
می‌خواهیم قدرت پردازشی سرور‌ها بیشتر باشد اصلاً در معماری نرم‌افزار آن را مطرح
نمی‌کنیم. در معماری نرم‌افزار در مورد چگونگی ساخت نرم‌افزار از اجزای آن،
ارتباطات و وظایف آن‌ها صحبت می‌کنیم. سرعت‌ها، هزینه‌ها، پهنای باند، ارسال تراکنش
در ثانیه و غیره هیچ وقت در معماری نرم‌افزاری دیده نمی‌شود بلکه در معماری سیستم
تعریف می‌شود. به طور کلی ذهن معمار از کلیه ملاحضات سخت‌افزاری به دور است. زیرا
در سخت افزار نمی‌توانیم قدرت انعطاف‌پذیری که در نرم‌افزار داریم را داشته باشیم
ولی به گونه‌ای است که ویژگی‌های کیفی ما کاملاً با سخت‌افزار در ارتباط می‌باشد.

\subsection{دیدگاه و ساختار یا \lr{View and Structure}}

دیدگاه و ساختار هر دو کاملاً روی یک سکه هستند:

\begin{itemize}
    \item یک دیدگاه نمایشی از مجموعه‌ای منسجم از معماری المان‌ها می‌باشد که شامل
    المان‌ها و روابط بین آن‌ها می‌شود.
    \item یک ساختار مجموعه‌ای از المان‌ها می‌باشد که یا در سخت‌افزار یا در
    نرم‌افزار وجود دارد.
\end{itemize}

\subsection{سه نوع ساختار‌ها}

\subsubsection{\lr{Module} یا ساختار‌های ماژول}

ماژول‌ها یک روش مبتنی بر کد برای بررسی سیستم هستند و به بخش‌های وظیفه‌مندی سیستم
اشاره دارند. این بخش یک دید ثابت دارد. معمولاً سوالات زیر در ماژول‌ها بیان
می‌شود:

\begin{itemize}
    \item \lr{Uses}: در این قسمت مشخص می‌شود که ارتباطات بین عناصر و المان‌ها به
    چه صورتی است.
    \item \lr{Layered}: مشخص می‌شود که هر کدام از المان‌ها در چه لایه‌ای قرار
    می‌گیرند.
    \item \lr{Class}: کلاس‌ها و مدل‌های نرم‌افزاری (موجودیت‌ها) در این قسمت
    تعریف می‌شوند و چون کلاس‌ها به صورت ثابت می‌باشند برخی از اعضای تیم
    نرم‌افزار سه نوع ساختار معماری را ثابت می‌بینند.
    \item \lr{Decomposition}: ماژول‌ها می‌توانند متشکل از چندین زیر ماژول باشند
    که در تمیزی کد و توسعه و دیباگینگ مناسب کمک بسیار زیادی کند. در اینجا مشخص
    می‌شود که چگونه ماژول‌های بزرگ‌تر به ماژول‌های کوچک‌تر جهت مدیریت کد بهتر
    تقسیم می‌شوند.
\end{itemize}

\subsubsection{\lr{Component-and-Connector}}

اجزای این ساختار کامپوننت‌ها در زمان اجرا و اتصال‌هایشان می‌باشد. یک دید پویا
دارد برای تغییرات در حین اجرا.

\begin{itemize}
    \item \lr{Client-Server} نرم‌افزار از چه الگویی استفاده می‌کند.
    \item \lr{Concurrency}: بحث همزمانی تراکنش‌ها و درخواست‌ها در اینجا مطرح
    می‌شود. کدام بخش‌های سیستم می‌توانند به صورت همزمان اجرا شوند؟
    \item \lr{Process}: بحث فرایند‌ها را با استفاده از نمودار‌های \lr{Activity}
    نمایش می‌دهند تا بتوانند فرایند را از صفر تا صد تعریف کنند. چگونه داده‌ها در
    سرتاسر سیستم حرکت می‌کنند؟
    \item \lr{Shared Data}: مخزن داده مشترک اصلی چه چیزی است؟
    \item کدام بخش از سیستم تکرار شده است؟
    \item چگونه می‌توان ساختار سیستم را زمانی که در حال اجرا است تغییر داد؟
\end{itemize}

\subsubsection{\lr{Allocation} یا اختصاص منابع}

\begin{itemize}
    \item \lr{Work assignment}: این ساختار در مورد اختصاص کار‌ها و اسناد مربوط
    به استقرار صحبت می‌کند. اختصاص منابع نرم‌افزاری به سخت‌افزار و برعکس
    می‌باشد.
    \item سند استقرار یا \lr{Deployment document}
    \item سند \lr{Activity} و \lr{Business Processing Model Notation}
    \item \lr{Deployment}: استقرار در حقیقت، تحلیل کارایی، قابلیت دسترس‌پذیری و
    امنیت را مطرح می‌کند.
    \item \lr{Assigned to}: انتساب کار، مدیریت پروژه، استفاده بهتر از تجارب،
    مدیریت بهتر دارایی‌ها
\end{itemize}

نیاز‌های \lr{N-FR} را نمی‌توان خارج از نیاز‌های \lr{FR} سیستم در نظر بگیرم.
نیاز‌های عملیاتی را با استفاده از \lr{Usecase}ها نمایش می‌دهیم که در حقیقت
سناریو‌های سیستم را مطرح می‌کند.