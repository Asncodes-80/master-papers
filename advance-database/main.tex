\documentclass[a4paper]{article}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{plantuml}
\usetikzlibrary{arrows, shapes, automata, petri, positioning, calc}
\usepackage{graphicx}
\usepackage{ragged2e}
\usepackage{color}
\usepackage{xepersian}
\usepackage{subfiles}
\settextfont[Scale=1]{XB Roya}
\renewcommand{\baselinestretch}{1.5}

\begin{document}
\centerline{پایگاه داده پیشرفته}
\centerline{دکتر شجاعی مهر}
\centerline{علیرضا سلطانی نشان}
\centerline{\today}

\tableofcontents

\newpage

\section{مفاهیم}

\subsection{تراکنش}

تراکنش واحد اجرای برنامه است. عملیاتی که در هر تراکنش می‌تواند شامل شود موارد
زیر می‌باشد:

\begin{itemize}
    \item Create
    \item Read
    \item Update
    \item Delete
\end{itemize}

\subsection{قوانین \lr{ACID}}

\subsubsection{اتمیک یا \lr{Atomicity}}

هر تراکنش دیتابیس به صورت اتمیک می‌باشد. این قضیه بدان معناست که این تراکنش یا
باید کاملا انجام شود یا کلا لغو و صرف نظر شود. در غیر این صورت اگر تراکنش به
صورت ناتمام و ناقص انجام شود عواقب مختلفی روی دیتابیس خواهد گذاشت.

\subsubsection{جامعیت یا \lr{Consistency}}

هر تراکنش باید از قوانین جامعیت پیروی کند. نمی‌توان داده یا را وارد جدولی از
دیتابیس کرد که به صورت معتبر نباشد. در برخی از مراجع این قانون را به اجرای صحیح
و سازگار تراکنش می‌شناسند. مهم ترین مثال آن است که شما یک \lr{Validation} روی یک
مقداری از فیلد جدول تنظیم می‌کنید که هر داده‌ای بر روی آن فقط با شرایط تعریف شده
بایستی وارد شود.

خالی از لطف نیست که در مورد مرجع پذیری داده‌ها در این قسمت نیز می‌توان صحبت کرد
تا بتواند قوانین جامعیت را به طور صحیح کامل کرد. مرجع پذیری زمانی مطرح می‌شود که
یک رکوردی از داده وقتی وارد جدولی از دیتابیس می‌شود ممکن است ارتباط مشخصی با
جدولی دیگر داشته باشد. پس به همین خاطر کلید‌های اصلی و خارجی در خصوص جامعیت وجود
دارند که داده‌ای معنادار را پس از پرس و جو از دیتابیس به برنامه نویس برگرداند.
یادآوری، بخش جوین‌ها در دیتابیس و تعریف رفرنس در هنگام تعریف کلید جانبی.

\subsubsection{انزوا یا \lr{Isolation}}

هر سیستم جامع پایگاه داده‌ای باید بتواند روی همروند تراکنش‌ها مدیریت و کنترل
کامل داشته باشد. انزوا تراکنش‌ها قابلیت کنترل و تنظیم بر اساس \lr{DBMS} است.

به طور کل همروندی یا همزمانی به حالتی گفته می‌شود که چند تراکنش بخواهند در یک
زمان به صورت موازی روی یک منبع عملیات خواندن و نوشتن را انجام دهند. اما این
عملیات به طور کل هزینه خاص و مشخصی برای برنامه نویس و مدیر دیتابیس دارد.

\subsubsection{قابلیت اعتماد یا \lr{Duribility}}

قابلیت اعتماد یکی از مهم‌ترین ویژگی‌های هر سیستم دیتابیسی است. یعنی بتوان
داده‌ها را در پایگاه‌داده به صورت پایدار و ثابت نگهداری و مراقبت کرد. در صورت
بروز مشکل روی داده‌های یک دیتابیس می‌توان به عملیات انجام شده در این قسمت مراجعه
کرد. بطور کلی این بخش قابلیت کنترل و مدیریت دارد و می‌توان مجموعه فرایند‌های
نگهداری و بک‌آپ را به صورت خودکار انجام داد.

\subsection{تنظیم قابلیت انزوا}

انزوا و مدیریت همروندی در دیتابیس به چهار طریق قابل انجام است:

\begin{enumerate}
    \item \lr{Read uncommitted}
    \item \lr{Read commmitted} 
    \item \lr{Repeadable read}
    \item \lr{Serializable}
\end{enumerate}

یادآوری: هر تراکنش دو حالت در پایان پیدا می‌کند:

\begin{itemize}
    \item \lr{Commit}: تراکنش درنهایت تایید و انجام می‌شود
    \item \lr{Abort}: تراکنش در نهایت سقط یا صرفه نظر می‌شود
\end{itemize}

\subsubsection{وضعیت تراکنش}


نکته: \lr{Abort} در دو شرط اتفاق می‌افتد:

\begin{enumerate}
    \item زمانی که اجرای تراکنش به خطای \lr{Run time} دچار شود.
    \item خرابی و نقص سیستم که روی اجرای تراکنش تاثیر می‌گذارد که کامل نشود
\end{enumerate}

\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{umls/transactionStatus.png}
    \caption{نمودار شروع فرایند تراکنش‌ها}
    \label{fig: uml}
\end{figure}

\newpage

\subsection{همروندی}

\subsubsection{مزیت همروندی}

\begin{enumerate}
    \item افزایش سرعت گذردهی یا \lr{throughput}
    \item کاهش میانگین زمان پاسخدهی به تراکنش مورد نظر
\end{enumerate}

\subsubsection{معایب همروندی} 

\begin{enumerate}
    \item \lr{Last update}: تغییرات گمشده به دلیل همزمانی در خواندن و نوشتن
    قانون \lr{Write before Write}
    \item \lr{Uncommitted}: خواندن داده‌ای که معتبر نیست. معمولا به آن \lr{Dirty
    read} هم گفته می‌شود. قانون \lr{Write before Read}
    \item \lr{Inconsistent retrieval}: بازیابی داده‌ای که ناهمگان است. \lr{Read
    before Write}
\end{enumerate}

\subsection{زمان‌بندی}

زمان‌بندی به اجرای همروند و همزمان چندین تراکنش با هم گفته می‌شود.

\subsection{نظریه پی در پی پذیری زمان‌بندی‌ها}

به دو روش می‌توان به پی در پی پذیری رسید:

\begin{enumerate}
    \item \lr{Conflict serializability}
    \item \lr{View serializability}
\end{enumerate}

نماد‌های مورد استفاده برای تعریف تراکنش‌ها:

\begin{itemize}
    \item $R_{i}| Q |$
    \item $W_{i}| Q |$
    \item $C_{i}| Q |$
    \item $A_{i}| Q |$
    \item $B_{i}| Q |$
    \item $E_{i}| Q |$
\end{itemize}

\subsection{سه شرط اصلی تصادم}

اگر $p_{i}$ و $q_{j}$ دو تراکنش باشند:

\begin{enumerate}
    \item \lr{i != j}
    \item هر دو به یک داده دسترسی داشته باشند
    \item حداقل یکی از دستورات عمل نوشتن یا \lr{write} داشته باشد
\end{enumerate}


\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{حالات تصادم}
        \end{RTL}
        \begin{tabular}{|c|c|c|}
            \hline
            & $R_{i}(Q)$ & $W_{j}(Q)$ \\ \hline
            $R_{i}(Q)$ & ندارد &  دارد  \\ \hline
            $W_{j}(Q)$ & دارد & دارد  \\ \hline
        \end{tabular}
    \end{table}
\end{LTR}

\subsection{زمان‌بندی سریالی}

در زمان‌بندی پی در پی، زمانی که یک تراکنش \lr{commit} یا \lr{abort} شود به دنبال
تراکنش بعدی خواهد رفت که به آن تراکنش سریالی یا \lr{Serializable schedule}
می‌گویند.

\begin{LTR}
  \lr{$S_{1} = R_{1}(A) W_{1}(A) a_{1} W_{2}(A) W_{2}(B) C_{2}$}
\end{LTR}

زمان‌بندی سریالی بالا در حقیقت به دو فرایند تقسیم می‌شود. چرا که در انتهای
تراکنش اول پیام سقوط کرده و برنامه به دنبال فرایند بعدی رفته است که روی منبع
دیگری در حال انجام پردازش است.

فرایند نافرجام اول:

\begin{LTR}
  \lr{$S_{1} = R_{1}(A) W_{1}(A) a_{1}$}
\end{LTR}

فرایند \lr{commit} شده دوم:

\begin{LTR}
  \lr{$S_{1} = W_{2}(A) W_{2}(B) C_{2}$}
\end{LTR}

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{تراکنش‌های سریالی پی در پی}
        \end{RTL}
        \begin{tabular}{|c|c|c|c|c|c|c|}
            \hline
            $T_{1}$ & $R_{1}(A)$ & $W_{1}(A)$ & $a_{1}$ & & & \\ \hline
            $T_{2}$ & & & & $W_{2}(A)$ & $W_{2}(B)$ & $C_{2}$ \\ \hline
        \end{tabular}
    \end{table}
\end{LTR}

\subsection{زمان‌بندی‌های معادل در برخورد یا \lr{Conflict equivalent}}

زمانی که دستورات یک زمان‌بندی را وارد زمانبندی دیگر کنیم به گونه‌ای که باعث تصادم
و برخورد نشود، این دستورات در این زمان‌بندی با هم معادل در برخورد هستند.

با توجه به تراکنش‌های \lr{$t_{1}$} و \lr{$t_{2}$} و \lr{$t_{3}$} و \lr{$t_{4}$}
زیر، می‌توان دریافت که این دو تراکنش با یکدیگر معادل در برخورد هستند. به گونه‌ای
که بعد از جا به جایی هیچ تصادمی رخ نداده است.

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{تراکنش‌های معادل در برخورد اول}
        \end{RTL}
        \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
            \hline
            $T_{1}$ & $R(Q)$ & $W(Q)$ & & $R(P)$ & & $W(P)$ & $C$ & & & \\ \hline
            $T_{2}$ & & & $R(Q)$ & & $W(Q)$ & &  & $R(Q)$ & $W(Q)$ & $C$ \\ \hline
        \end{tabular}
    \end{table}
\end{LTR}

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{تراکنش‌های معادل در برخورد دوم}
        \end{RTL}
        \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
            \hline
            $T_{3}$ & $R(Q)$ & $W(Q)$ & & $R(P)$ & $W(P)$ & & $C$ & & & \\ \hline
            $T_{4}$ & & & $R(Q)$ & & & $W(Q)$ &  & $R(Q)$ & $W(Q)$ & $C$ \\ \hline
        \end{tabular}
    \end{table}
\end{LTR}

\newpage

اما در مثال بعد هر دو تراکنش \lr{$t_{1}$} و \lr{$t_{2}$} مستعد به برخورد در یکی
از فرایند‌ها در زمان هستند.

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{تراکنش‌های معادل در برخورد اول}
        \end{RTL}
        \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
            \hline
            $T_{1}$ & $R(Q)$ & $W(Q)$ & & $R(P)$ & & $W(P)$ & $C$ & & & \\ \hline
            $T_{2}$ & & & $R(Q)$ & & $W(Q)$ & &  & $R(Q)$ & $W(Q)$ & $C$ \\ \hline
        \end{tabular}
    \end{table}
\end{LTR}


\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{تراکنش‌های معادل در برخورد اول}
        \end{RTL}
        \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
            \hline
            $T_{1}$ & $R(Q)$ & $W(Q)$ & & $R(P)$ & & $W(P)$ & $C$ & & & \\ \hline
            $T_{2}$ & & $R(Q)$ & $R(Q)$ & & $W(Q)$ & &  & $R(Q)$ & $W(Q)$ & $C$ \\ \hline
        \end{tabular}
    \end{table}
\end{LTR}

\subsection{گراف پی در پی پذیر}

کامپیوتر برای تشخیص وجود برخورد در تراکنش‌ها از تئوری گراف پی در پی پذیر استفاده
می‌کند. در این روش به صورت بصری ارتباطات تراکنش‌ها را ‌نسبت به یکدیگر را نمایش
می‌دهیم. در صورتی که بین دو یا چند تراکنش دور یا حلقه ایجاد شود، می‌گوییم که این
تراکنش‌ها با هم برخورد دارند.

سیستم DBM از گراف زمان اجرا خبر دارد و دائما در حال بروزرسانی آن است. اگر وجود
دور یا حلقه را تشخیص دهد، برخورد را بررسی کرده و اعلام می‌کند که این تراکنش‌ها
پی در پی پذیر در برخورد نیستند و از اجرای این تراکنش‌ها جلوگیری می‌کند.

\subsubsection{کشتن فرایند تراکنش‌ها}

منظور از جلوگیری می‌تواند به دو روش باشد: یا کلا از اجرای تراکنش‌ها جلوگیری
می‌کند یا بررسی می‌کند که کدام تراکنش یا تراکنش‌ها باعث ایجاد برخورد در
تراکنش‌های دیگر می‌شود، آن را تشخیص داده و تراکنش آن را می‌کشد \footnote{\lr{Kill
transaction}}.

\newpage

برای مثال تراکنش‌های زیر را در نظر بگیرید:

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{تراکنش‌های بانکی}
        \end{RTL}
        \begin{tabular}{|c|c|c|c|c|c|}
            \hline
            $T_{5}$ & & & W(Q) & & \\ \hline
            $T_{6}$ & R(Q) & & & & W(Q) \\ \hline
            $T_{7}$ & & W(Q) & & & \\ \hline
            $T_{8}$ & & & & R(Q) & \\ \hline
        \end{tabular}
    \end{table}
\end{LTR}

گراف این تراکنش‌ها به شکل زیر است. توجه شود که هر تراکنش می‌تواند به صورت ترتیبی
نسبت به تراکنشی بعدی خود ارتباط داشته باشد. در صورتی که حلقه ایجاد شود بایستی
عامل ایجاد حلقه پیدا و سپس کشته شود.

\newpage

\begin{figure}
    \centering
    \includegraphics[width=0.3\textwidth]{umls/exp1_serializable_graph.jpg}
    \caption{گراف تراکنش‌ها و ایجاد ارتباطات حلقه دار}
    \label{fig: diagram}
\end{figure}

در این مثال برای حذف حلقه می‌تواند یکی یکی تراکنش‌های مورد نظر را بررسی کرد و در
صورت حذف یکی از تراکنش‌ها حلقه حذف شد می‌توان آن را نتیجه گرفت و اعلام کرد این
تراکنش‌ها باهم سازگارند و برخورد ایجاد نمی‌کنند. در نهایت سیستم DBM تصمیم به
اجرای تراکنش‌ها خواهد کرد.

\begin{figure}
    \centering
    \includegraphics[width=0.3\textwidth]{umls/exp1_solved.jpg}
    \caption{تراکنش حذف شده و ایجاد گرافی بدون حلقه}
    \label{fig: diagram}
\end{figure}

\newpage

\subsection{پی در پی پذیری در دید یا \lr{View equivalent}}


زمانی می‌گوییم پی در پی پذیری در دید برقرار است که نتایج \underline{یکسانی} در
سیستم DBM با یک زمان‌بندی پی در پی داشته باشیم.

سه قاعده اصلی پی در پی پذیری در دید:

\begin{enumerate}
    \item برای هر داده Q تراکنشی که در S مقدار اولیه داده‌ای Q  را می‌خواند در
    S' هم همان تراکنش اولیه مقدار Q را بخواند (خواندن‌های اولیه)
    \item برای هر داده‌ Q اگر $t_{i}$ در S داده‌ Q را از $t_{j}$ می‌خواند، در S'
    هم $t_{i}$ همان داده‌ را از $t_{j}$ بخواند. (خواندن‌های میانی)
    \item برای هر داده Q آخرین تراکنشی از S که روی Q می‌نویسد در S' هم همان
    تراکنش نوشتن پایانی را روی Q انجام دهد. (نوشتن‌های پایانی)
\end{enumerate}

\end{document}