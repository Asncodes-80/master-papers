\documentclass[a4paper]{article}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{plantuml}
\usetikzlibrary{arrows, shapes, automata, petri, positioning, calc}
\usepackage{graphicx}
\usepackage{ragged2e}
\usepackage{color}
\usepackage{xepersian}
\usepackage{subfiles}
\settextfont[Scale=1]{XB Roya}
\renewcommand{\baselinestretch}{1.5}

\begin{document}
\centerline{پایگاه داده پیشرفته}
\centerline{دکتر شجاعی مهر}
\centerline{علیرضا سلطانی نشان}
\centerline{\today}
\tableofcontents

\newpage

\section{مفاهیم}

\subsection{تراکنش}

تراکنش واحد اجرای برنامه است. عملیاتی که در هر تراکنش می‌تواند شامل شود موارد
زیر می‌باشد:

\begin{itemize}
    \item Create
    \item Read
    \item Update
    \item Delete
\end{itemize}

\subsection{قوانین \lr{ACID}}

\subsubsection{اتمیک یا \lr{Atomicity}}

هر تراکنش دیتابیس به صورت اتمیک می‌باشد. این قضیه بدان معناست که این تراکنش یا
باید کاملا انجام شود یا کلا لغو و صرف نظر شود. در غیر این صورت اگر تراکنش به
صورت ناتمام و ناقص انجام شود عواقب مختلفی روی دیتابیس خواهد گذاشت.

\subsubsection{جامعیت یا \lr{Consistency}}

هر تراکنش باید از قوانین جامعیت پیروی کند. نمی‌توان داده یا را وارد جدولی از
دیتابیس کرد که به صورت معتبر نباشد. در برخی از مراجع این قانون را به اجرای صحیح
و سازگار تراکنش می‌شناسند. مهم ترین مثال آن است که شما یک \lr{Validation} روی یک
مقداری از فیلد جدول تنظیم می‌کنید که هر داده‌ای بر روی آن فقط با شرایط تعریف شده
بایستی وارد شود.

خالی از لطف نیست که در مورد مرجع پذیری داده‌ها در این قسمت نیز می‌توان صحبت کرد
تا بتواند قوانین جامعیت را به طور صحیح کامل کرد. مرجع پذیری زمانی مطرح می‌شود که
یک رکوردی از داده وقتی وارد جدولی از دیتابیس می‌شود ممکن است ارتباط مشخصی با
جدولی دیگر داشته باشد. پس به همین خاطر کلید‌های اصلی و خارجی در خصوص جامعیت وجود
دارند که داده‌ای معنادار را پس از پرس و جو از دیتابیس به برنامه نویس برگرداند.
یادآوری، بخش جوین‌ها در دیتابیس و تعریف رفرنس در هنگام تعریف کلید جانبی.

\subsubsection{انزوا یا \lr{Isolation}}

هر سیستم جامع پایگاه داده‌ای باید بتواند روی همروند تراکنش‌ها مدیریت و کنترل
کامل داشته باشد. انزوا تراکنش‌ها قابلیت کنترل و تنظیم بر اساس \lr{DBMS} است.

به طور کل همروندی یا همزمانی به حالتی گفته می‌شود که چند تراکنش بخواهند در یک
زمان به صورت موازی روی یک منبع عملیات خواندن و نوشتن را انجام دهند. اما این
عملیات به طور کل هزینه خاص و مشخصی برای برنامه نویس و مدیر دیتابیس دارد.

\subsubsection{قابلیت اعتماد یا \lr{Duribility}}

قابلیت اعتماد یکی از مهم‌ترین ویژگی‌های هر سیستم دیتابیسی است. یعنی بتوان
داده‌ها را در پایگاه‌داده به صورت پایدار و ثابت نگهداری و مراقبت کرد. در صورت
بروز مشکل روی داده‌های یک دیتابیس می‌توان به عملیات انجام شده در این قسمت مراجعه
کرد. بطور کلی این بخش قابلیت کنترل و مدیریت دارد و می‌توان مجموعه فرایند‌های
نگهداری و بک‌آپ را به صورت خودکار انجام داد.

\subsection{تنظیم قابلیت انزوا}

انزوا و مدیریت همروندی در دیتابیس به چهار طریق قابل انجام است:

\begin{enumerate}
    \item \lr{Read uncommitted}
    \item \lr{Read commmitted} 
    \item \lr{Repeadable read}
    \item \lr{Serializable}
\end{enumerate}

یادآوری: هر تراکنش دو حالت در پایان پیدا می‌کند:

\begin{itemize}
    \item \lr{Commit}: تراکنش درنهایت تایید و انجام می‌شود
    \item \lr{Abort}: تراکنش در نهایت سقط یا صرفه نظر می‌شود
\end{itemize}

\subsubsection{وضعیت تراکنش}


نکته: \lr{Abort} در دو شرط اتفاق می‌افتد:

\begin{enumerate}
    \item زمانی که اجرای تراکنش به خطای \lr{Run time} دچار شود.
    \item خرابی و نقص سیستم که روی اجرای تراکنش تاثیر می‌گذارد که کامل نشود
\end{enumerate}

% \begin{figure}
%     \centering
%     \includegraphics[width=0.5\textwidth]{umls/transactionStatus.png}
%     \caption{نمودار شروع فرایند تراکنش‌ها}
%     \label{fig: uml}
% \end{figure}

\newpage

\subsection{همروندی}

\subsubsection{مزیت همروندی}

\begin{enumerate}
    \item افزایش سرعت گذردهی یا \lr{throughput}
    \item کاهش میانگین زمان پاسخدهی به تراکنش مورد نظر
\end{enumerate}

\subsubsection{معایب همروندی} 

\begin{enumerate}
    \item \lr{Last update}: تغییرات گمشده به دلیل همزمانی در خواندن و نوشتن
    قانون \lr{Write before Write}
    \item \lr{Uncommitted}: خواندن داده‌ای که معتبر نیست. معمولا به آن \lr{Dirty
    read} هم گفته می‌شود. قانون \lr{Write before Read}
    \item \lr{Inconsistent retrieval}: بازیابی داده‌ای که ناهمگان است. \lr{Read
    before Write}
\end{enumerate}

\subsection{زمان‌بندی}

زمان‌بندی به اجرای همروند و همزمان چندین تراکنش با هم گفته می‌شود.

\subsection{نظریه پی در پی پذیری زمان‌بندی‌ها}

به دو روش می‌توان به پی در پی پذیری رسید:

\begin{enumerate}
    \item \lr{Conflict serializability}
    \item \lr{View serializability}
\end{enumerate}

نماد‌های مورد استفاده برای تعریف تراکنش‌ها:

\begin{itemize}
    \item $R_{i}| Q |$
    \item $W_{i}| Q |$
    \item $C_{i}| Q |$
    \item $A_{i}| Q |$
    \item $B_{i}| Q |$
    \item $E_{i}| Q |$
\end{itemize}

\subsection{سه شرط اصلی تصادم}

اگر $p_{i}$ و $q_{j}$ دو تراکنش باشند:

\begin{enumerate}
    \item \lr{i != j}
    \item هر دو به یک داده دسترسی داشته باشند
    \item حداقل یکی از دستورات عمل نوشتن یا \lr{write} داشته باشد
\end{enumerate}


\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{حالات تصادم}
        \end{RTL}
        \begin{tabular}{|c|c|c|}
            \hline
            & $R_{i}(Q)$ & $W_{j}(Q)$ \\ \hline
            $R_{i}(Q)$ & ندارد &  دارد  \\ \hline
            $W_{j}(Q)$ & دارد & دارد  \\ \hline
        \end{tabular}
    \end{table}
\end{LTR}

\subsection{زمان‌بندی سریالی}

در زمان‌بندی پی در پی، زمانی که یک تراکنش \lr{commit} یا \lr{abort} شود به دنبال
تراکنش بعدی خواهد رفت که به آن تراکنش سریالی یا \lr{Serializable schedule}
می‌گویند.

\begin{LTR}
  \lr{$S_{1} = R_{1}(A) W_{1}(A) a_{1} W_{2}(A) W_{2}(B) C_{2}$}
\end{LTR}

زمان‌بندی سریالی بالا در حقیقت به دو فرایند تقسیم می‌شود. چرا که در انتهای
تراکنش اول پیام سقوط کرده و برنامه به دنبال فرایند بعدی رفته است که روی منبع
دیگری در حال انجام پردازش است.

فرایند نافرجام اول:

\begin{LTR}
  \lr{$S_{1} = R_{1}(A) W_{1}(A) a_{1}$}
\end{LTR}

فرایند \lr{commit} شده دوم:

\begin{LTR}
  \lr{$S_{1} = W_{2}(A) W_{2}(B) C_{2}$}
\end{LTR}

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{تراکنش‌های سریالی پی در پی}
        \end{RTL}
        \begin{tabular}{|c|c|c|c|c|c|c|}
            \hline
            $T_{1}$ & $R_{1}(A)$ & $W_{1}(A)$ & $a_{1}$ & & & \\ \hline
            $T_{2}$ & & & & $W_{2}(A)$ & $W_{2}(B)$ & $C_{2}$ \\ \hline
        \end{tabular}
    \end{table}
\end{LTR}

\subsection{زمان‌بندی‌های معادل در برخورد یا \lr{Conflict equivalent}}

زمانی که دستورات یک زمان‌بندی را وارد زمانبندی دیگر کنیم به گونه‌ای که باعث تصادم
و برخورد نشود، این دستورات در این زمان‌بندی با هم معادل در برخورد هستند.

با توجه به تراکنش‌های \lr{$t_{1}$} و \lr{$t_{2}$} و \lr{$t_{3}$} و \lr{$t_{4}$}
زیر، می‌توان دریافت که این دو تراکنش با یکدیگر معادل در برخورد هستند. به گونه‌ای
که بعد از جا به جایی هیچ تصادمی رخ نداده است.

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{تراکنش‌های معادل در برخورد اول}
        \end{RTL}
        \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
            \hline
            $T_{1}$ & $R(Q)$ & $W(Q)$ & & $R(P)$ & & $W(P)$ & $C$ & & & \\ \hline
            $T_{2}$ & & & $R(Q)$ & & $W(Q)$ & &  & $R(Q)$ & $W(Q)$ & $C$ \\ \hline
        \end{tabular}
    \end{table}
\end{LTR}

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{تراکنش‌های معادل در برخورد دوم}
        \end{RTL}
        \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
            \hline
            $T_{3}$ & $R(Q)$ & $W(Q)$ & & $R(P)$ & $W(P)$ & & $C$ & & & \\ \hline
            $T_{4}$ & & & $R(Q)$ & & & $W(Q)$ &  & $R(Q)$ & $W(Q)$ & $C$ \\ \hline
        \end{tabular}
    \end{table}
\end{LTR}

\newpage

اما در مثال بعد هر دو تراکنش \lr{$t_{1}$} و \lr{$t_{2}$} مستعد به برخورد در یکی
از فرایند‌ها در زمان هستند.

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{تراکنش‌های معادل در برخورد اول}
        \end{RTL}
        \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
            \hline
            $T_{1}$ & $R(Q)$ & $W(Q)$ & & $R(P)$ & & $W(P)$ & $C$ & & & \\ \hline
            $T_{2}$ & & & $R(Q)$ & & $W(Q)$ & &  & $R(Q)$ & $W(Q)$ & $C$ \\ \hline
        \end{tabular}
    \end{table}
\end{LTR}


\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{تراکنش‌های معادل در برخورد اول}
        \end{RTL}
        \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
            \hline
            $T_{1}$ & $R(Q)$ & $W(Q)$ & & $R(P)$ & & $W(P)$ & $C$ & & & \\ \hline
            $T_{2}$ & & $R(Q)$ & $R(Q)$ & & $W(Q)$ & &  & $R(Q)$ & $W(Q)$ & $C$ \\ \hline
        \end{tabular}
    \end{table}
\end{LTR}

\subsection{گراف پی در پی پذیر}

کامپیوتر برای تشخیص وجود برخورد در تراکنش‌ها از تئوری گراف پی در پی پذیر استفاده
می‌کند. در این روش به صورت بصری ارتباطات تراکنش‌ها را ‌نسبت به یکدیگر را نمایش
می‌دهیم. در صورتی که بین دو یا چند تراکنش دور یا حلقه ایجاد شود، می‌گوییم که این
تراکنش‌ها با هم برخورد دارند.

سیستم DBM از گراف زمان اجرا خبر دارد و دائما در حال بروزرسانی آن است. اگر وجود
دور یا حلقه را تشخیص دهد، برخورد را بررسی کرده و اعلام می‌کند که این تراکنش‌ها
پی در پی پذیر در برخورد نیستند و از اجرای این تراکنش‌ها جلوگیری می‌کند.

\subsubsection{کشتن فرایند تراکنش‌ها}

منظور از جلوگیری می‌تواند به دو روش باشد: یا کلا از اجرای تراکنش‌ها جلوگیری
می‌کند یا بررسی می‌کند که کدام تراکنش یا تراکنش‌ها باعث ایجاد برخورد در
تراکنش‌های دیگر می‌شود، آن را تشخیص داده و تراکنش آن را می‌کشد \footnote{\lr{Kill
transaction}}.

\newpage

برای مثال تراکنش‌های زیر را در نظر بگیرید:

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{تراکنش‌های بانکی}
        \end{RTL}
        \begin{tabular}{|c|c|c|c|c|c|}
            \hline
            $T_{5}$ & & & W(Q) & & \\ \hline
            $T_{6}$ & R(Q) & & & & W(Q) \\ \hline
            $T_{7}$ & & W(Q) & & & \\ \hline
            $T_{8}$ & & & & R(Q) & \\ \hline
        \end{tabular}
    \end{table}
\end{LTR}

گراف این تراکنش‌ها به شکل زیر است. توجه شود که هر تراکنش می‌تواند به صورت ترتیبی
نسبت به تراکنشی بعدی خود ارتباط داشته باشد. در صورتی که حلقه ایجاد شود بایستی
عامل ایجاد حلقه پیدا و سپس کشته شود.

\newpage

% \begin{figure}
%     \centering
%     \includegraphics[width=0.3\textwidth]{umls/exp1_serializable_graph.jpg}
%     \caption{گراف تراکنش‌ها و ایجاد ارتباطات حلقه دار}
%     \label{fig: diagram}
% \end{figure}

در این مثال برای حذف حلقه می‌تواند یکی یکی تراکنش‌های مورد نظر را بررسی کرد و در
صورت حذف یکی از تراکنش‌ها حلقه حذف شد می‌توان آن را نتیجه گرفت و اعلام کرد این
تراکنش‌ها باهم سازگارند و برخورد ایجاد نمی‌کنند. در نهایت سیستم DBM تصمیم به
اجرای تراکنش‌ها خواهد کرد.

% \begin{figure}
%     \centering
%     \includegraphics[width=0.3\textwidth]{umls/exp1_solved.jpg}
%     \caption{تراکنش حذف شده و ایجاد گرافی بدون حلقه}
%     \label{fig: diagram}
% \end{figure}

\subsection{پی در پی پذیری در دید یا \lr{View equivalent}}

زمانی می‌گوییم پی در پی پذیری در دید برقرار است که نتایج \underline{یکسانی} در
سیستم DBM با یک زمان‌بندی پی در پی داشته باشیم.

سه قاعده اصلی پی در پی پذیری در دید:

\begin{enumerate}
    \item برای هر داده Q تراکنشی که در S مقدار اولیه داده‌ای Q  را می‌خواند در
    S' هم همان تراکنش اولیه مقدار Q را بخواند (خواندن‌های اولیه)
    \item برای هر داده‌ Q اگر $t_{i}$ در S داده‌ Q را از $t_{j}$ می‌خواند، در S'
    هم $t_{i}$ همان داده‌ را از $t_{j}$ بخواند. (خواندن‌های میانی)
    \item برای هر داده Q آخرین تراکنشی از S که روی Q می‌نویسد در S' هم همان
    تراکنش نوشتن پایانی را روی Q انجام دهد. (نوشتن‌های پایانی)
\end{enumerate}

نکته: یک زمانبندی پی در پی پذیر در دید است، هنگامی که معادل در دید با یک
زمانبندی پی در پی پذیر باشد که نتایج درستی را منعکس کند.

\subsection{مثال اول پی در پی پذیری در دید}

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{پی در پی پذیری در دید}
        \end{RTL}
        \begin{tabular}{c|c|c|c|c|c}
            $T_{5}$ & & & W(Q) & & \\ \hline
            $T_{6}$ & R(Q) & & & &  \\ \hline
            $T_{7}$ & & W(Q) & & & W(Q) \\ \hline
            $T_{8}$ & & & & R(Q) & \\
        \end{tabular}
    \end{table}
\end{LTR}

پی در پی پذیر در دید است چرا که فرایند خواندن اولیه و عملیات میانی و در نهایت
نوشتن پایانی را دارا می‌باشد.

\begin{LTR}
    $T_{6}$ > ....... > $T_{7}$

    $T_{6}$ > $T_{5}$ > $T_{8}$ > $T_{7}$
\end{LTR}

اما پی در پی پذیر در برخورد نیست چرا که بین تراکنش $T_{7}$ و $T_{8}$ یک حلقه
ایجاد می‌شود و می‌تواند عاملی در برخورد باشد.

\newpage

\subsection{مثال دوم پی در پی پذیری در دید}

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{پی در پی پذیری در دید}
        \end{RTL}
        \begin{tabular}{c|c|c|c}
            $T_{3}$ & R(Q) & & W(Q) C \\ \hline
            $T_{4}$ & & W(Q) C &  \\ \hline
            $T_{5}$ & & & W(Q) C \\
        \end{tabular}
    \end{table}
\end{LTR}

جواب: این مثال پی در پی پذیر در دید است:

\begin{LTR}
    $T_{3}$ > ....... > $T_{5}$
\end{LTR}

چرا که در $T_{3}$ خواندن‌های اولیه صورت گرفته، در $T_{4}$ و زمان میانی $T_{3}$
عملیات میانی نوشتن رخ داده است. در انتها در تراکنش $T_{5}$ مطابق با قانون پی در
پی پذیری در دید نوشتن پایانی انجام شده است.

اما پی در پی پذیر در برخورد نیست چرا که در میان تراکنش‌ها حلقه رخ داده است.

% \begin{figure}
%     \centering
%     \includegraphics[width=0.4\textwidth]{umls/vsr_exp_2.jpg}
% \end{figure}

\newpage

\subsection{نمادگزاری}

کامپیوتر چگونه پی در پی پذیری در دید را متوجه می‌شود؟ با استفاده از نمادگزاری (خواندن از).

برای یک زمانبندی، مجموعه‌ای از (خواندن از‌)ها را تشکیل می‌دهیم. این مجموعه باید
با مجموعه خواندن از‌ها در یک زمانبندی پی در پی دیگر یکسان باشد تا در دید هم پی
در پی پذیر باشد.

\textcolor{red}{این بخش تکمیل نشده است. با استفاده از یک مسئله که عکس آن در کلاس
گرفته شده است.}


\subsection{یک زمانبندی ۲ شرط دارد که درست باشد:}

\begin{itemize}
    \item پی در پی پذیر باشد (قانون جامعیت در برخورد و دید برقرار باشد)
    \item ترمیم پذیر باشد
\end{itemize}

نکته: اگر یک زمانبندی پی در پی پذیر در برخورد باشد در دید هم پی در پی پذیر خواهد بود.

\subsection{زمانبندی ترمیم پذیر یا \lr{Recoverable scheduling}}

زمانبندی را ترمیم پذیر یا RC می‌گوییم که اگر برای تمام $T_{j}$هایی که از $T_{i}$
می‌خوانند کامیت اثباط تراکنش $T_{i}$ قبلی صورت گرفته باشد تا $T_{j}$ بتواند
مقدار زمانبندی وابسته قبلی را دریافت کند.

\subsubsection{سقوط‌های آبشاری یا \lr{Cascading Aborts}}

مثال ۱:

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{زمانبندی ترمیم ناپذیر}
        \end{RTL}
        \begin{tabular}{c|c|c|c|c}
            $T_{1}$ & R(A) & W(A) & A & \\ \hline
            $T_{2}$ & & & R(A) & C \\
        \end{tabular}
    \end{table}
\end{LTR}

این زمانبندی ترمیم پذیر نیست چرا که درست نیست. زیرا در زمانبندی $T_{1}$ بعد از
انجام تراکنش عمل سقوط یا Abort اتفاق افتاده است و $T_{2}$ در حال خواندن مقدار از
منبعی از زمانبندی بالاتر خود است که تراکنشش RollBack خواهد شد و به صورت صحیح
کامل نشده است.

\newpage

مثال ۲: 

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{زمانبندی ترمیم ناپذیر}
        \end{RTL}
        \begin{tabular}{c|c|c|c|c|c}
            $T_{1}$ & R(A) & W(A) & & R(B) & A \\ \hline
            $T_{2}$ & & & R(A) & & C \\
        \end{tabular}
    \end{table}
\end{LTR}

در این مثال هم مانند مثال قبل چون در تراکنش اول عمل Abort رخ داده است کل تراکنش
RollBack می‌شود و R(A) نمیتواند مقدار A را بخواند فلذا این جدول از تراکنش‌ها
درست نیستند و ترمیم ناپذیر اند.

مثال ۳:

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{tabular}{c|c|c|c|c|c}
            $T_{1}$ & R(A) & W(A) & C & R(B) & A \\ \hline
            $T_{2}$ & & & R(A) & & C \\
        \end{tabular}
    \end{table}
\end{LTR}

در این مثال تراکنش $T_{1}$ به دو قسمت تقسیم می‌شود. زمانی که کامیت کرده است و
زمانی که دیتا ساقط شده است. وقتی که عمل W(A) صورت میگیرد در این قسمت تراکنش اول
کامیت می‌شود و در راستای آن تراکنش $T_{2}$ به دلیل وابستگی به منبع A به تراکنش
بالایی خود با موفقیت می‌تواند مقدار را دریافت کند. این جدول تراکنش فاقد سقوط
آبشاری است. چرا که در ابتدا قسمتی از عملیات کامیت شده و قسمت دیگر سقوط کرده است.

\subsection{\lr{Avoiding Cascading Aborts}}

در حقیقت فرایند زمانی فاقد سقوط آبشاری است; اگر $T_{j}$ از $T_{i}$ بخواند آنگاه
$T_{i}$ قبل از خواندن $T_{j}$ کامیت شده باشد. بطور کل به آن ACA می‌گویند که جز
تراکنش‌های ترمیم پذیر می‌باشد.

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{نمونه‌ای از فرایند ACA}
        \end{RTL}
        \scalebox{0.7}{
            \begin{tabular}{c|c|c|c|c|c|c|c|c}
                $T_{1}$ & R(A) & R(B) & W(A) & C & & & & \\ \hline
                $T_{2}$ & & & & & R(A) & W(A) & C & \\ \hline
                $T_{3}$ & & & & & & & & R(A) \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

نکات:

\begin{itemize}
    \item در پی در پی پذیری تنها در مورد مشکلات همروندی صحبت می‌شد
    \item در زمانبندی‌های ACA هدف آن است که اول کامیت انجام شود و سپس خواندن
    منبع صورت گیرد در غیر این صورت زمان برای خواندن مقداری که تثبیط نشده است صرف
    می‌شود و زمان اصلی برای انجام فرایند‌های دیگر را از دست خواهیم داد.
\end{itemize}

\subsection{زمانبندی‌های محض یا Strict}

در دو تراکنش $T_{i}$ و $T_{j}$، اگر $T_{j}$ داده‌ای را پس از نوشتن $T_{i}$
بخواند بایستی قبل از آن Commit صورت گرفته باشد.

مثال: 

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{نمونه‌ای از زمانبندی محض}
        \end{RTL}
        \scalebox{0.9}{
            \begin{tabular}{c|c|c|c|c}
                $T_{1}$ & W(F) C & W(G) C & & \\ \hline
                $T_{2}$ & & & R(F) & R(G) \\ 
            \end{tabular}
        }
    \end{table}
\end{LTR}

مثال: زمانبندی زیر را از نظر محض بودن، ترمیم پذیری و ACA بررسی کنید.

نکته یکی از قوانین ترمیم پذیری عدم وجود سقوط‌های آبشاری است، پس اگر یک زمانبندی
ACA باشد پس ترمیم پذیر می‌باشد.

\begin{LTR}
    \begin{table}[h]
        \centering
        \scalebox{0.9}{
            \begin{tabular}{c|c|c|c|c|c}
                $T_{1}$ & R(A) & W(A) & C & \\ \hline
                $T_{2}$ & & & W(A) & W(B) & C \\ 
            \end{tabular}
        }
    \end{table}
\end{LTR}

\begin{itemize}
    \item زمانبندی بالا محض نیست چرا که بعد از هر بار نوشتن باید عمل کامیت صورت
    گیرد.
    \item زمانبندی بالا ترمیم پذیر است چرا که هیچ سقوطی رخ نداده است بلکه تراکنش
    $T_{1}$ در انتها کامیت شده و میتواند در تراکنش $T_{2}$ خوانده شود.
\end{itemize}

نکته: سیستم DBM از یکسری پروتکل‌هایی برای پی در پی پذیری و ترمیم پذیری استفاده
می‌کند تا دیتابیس به شکل صحیح کار کند. (پیروی از دو شرط اصلی)

\subsection{پروتکل‌های کنترل همروندی}

بعد از دیدن دستور ۳ کار انجام می‌شود:

\begin{enumerate}
    \item اجرای دستور
    \item به تاخیر انداختن دستور
    \item نپذیرفتن دستور یا سقوط آن
\end{enumerate}

\subsubsection{پروتکل‌های مبتنی بر قفل}

در این نوع پروتکل واحدی به نام \lr{Lock Manager} وارد تراکنش‌ها می‌شود و بررسی
میکند اگر ناسازگاری ww، wr یا rw وجود نداشته باشد اجازه خواندن را به تراکنش داده
خواهد شد و سپس بعد از آن که تراکنش کارش تمام شد می‌تواند قفل را تحویل دهد تا
تراکنش بعدی بتواند عملیات قفل گذاری را انجام دهد.

قفل‌ها دو نوع هستند:

\begin{enumerate}
    \item قفل‌های باینری
    \item قفل‌های اشتراکی/انحصاری یا \lr{Shared Exclusive Lock}: یک قفل برای
    خواندن (S) استفاده می‌کند و یک قفل برای نوشتن Mutex یا X.
\end{enumerate}

نکات: 

\begin{itemize}
    \item مزیت قفل‌های اشتراکی/انحصاری در انجام تراکنش‌ها به صورت موازی است
    \item اگه قفل به حالت ناسازگار برسد آن تراکنش را به تاخیر می‌اندازد
    \item قفل گذاری روی داده‌های زیاد با Seed بالا همروندی را کاهش می‌دهد
    \item وقتی Seed کم باشد Overhead زمانی خواهیم داشت و پردازش گران است
    \item قفل گذاری درست باعث می‌شود تا زمانبندی درست داشته باشیم
\end{itemize}

مثال:

\begin{LTR}
    \centering
    $S_{1}$ = $R_{1}(A)$ $W_{1}(A)$ $A_{1}$ $W_{2}(A)$ $W_{2}(B)$ $C$

    $S_{1}$ = $S_{1}(A)$ $R_{1}(A)$ $X_{1}(A)$ $W_{1}(A)$ $U_{1}(A)$ $A_{1}$ $X_{2}(A)$ $W_{2}(A)$ $X_{2}(B)$ $W_{2}(B)$ $U_{2}(A)$ $U_{2}(B)$ $C$
\end{LTR}

مثال کلید اشتراکی/انحصاری:

\begin{LTR}
    \begin{table}[h]
        \centering
        \scalebox{0.8}{
            \begin{tabular}{c|c|c|c|c|c}
                $T_{3}$ & & & W(Q) & & \\ \hline
                $T_{4}$ & R(Q) & & & W(Q) & \\ \hline
                $T_{5}$ & & W(Q) & & & \\ \hline
                $T_{6}$ & & & & & R(Q) \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

تبدیل جدول به سریال خطی:

\begin{LTR}
    $R_{4}(Q)$ $W_{5}(Q)$ $W_{3}(Q)$ $W_{4}(Q)$ $R_{5}(Q)$
\end{LTR}

حل:

\begin{LTR}
    \centering
    $\rightarrow$ 
    $S_{4}(Q)$ $R_{4}(Q)$ 
    $X_{5}(Q)$ $X_{3}(Q)$
    $X_{4}(Q)$ $W_{4}(Q)$ $U_{4}(Q)$
    $W_{5}(Q)$ $U_{5}(Q)$
    $W_{3}(Q)$ $U_{3}(Q)$
    $S_{6}(Q)$ $R_{6}(Q)$ $U_{6}(Q)$
\end{LTR}

\newpage

\subsection{بن بست و قحطی}

سوال: چه زمانی بن‌بست یا DeadLock رخ می‌دهد؟ زمانی که یک پردازه منتظر بدست آوردن
قفل باشد. مهم‌ترین راهکار برای کم کردن بن‌بست حذف یا Abort تراکنش باعث بن‌بست
است.

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{نمونه‌ای از تراکنش‌هایی که به بن‌بست بر خورده‌اند}
        \end{RTL}
        \centering
            \begin{tabular}{c|c|c|c|c|c}
                $T_{3}$ & x(B) & w(B) & & & x(A) \\ \hline
                $T_{4}$ & & s(A) & r(A) & s(B) & \\
            \end{tabular}
    \end{table}
\end{LTR}

جدول بالا به دلیل ناسازگاری WR و RW به بن‌بست بر می‌خورد. چرا که در تراکنش
$T_{3}$ برای نوشتن روی منبع B قفل نوشتن گذاشته شده است ولی Unlock نشده است و
تراکنش $T_{4}$ نمی‌تواند قفل خواندن را روی منبع A بگذارد چرا که تراکنش $T_{3}$
هنوز قفل را آزاد نکرده است. در این حالت یک انتظار چرخشی یا \lr{Unlimited wating}
بین تراکنش‌ها رخ داده است که دائما منتظر آزاد سازی قفل یکدگیر هستند تا بتوانند
بقیه عملیات را انجام دهند. بایستی در نظر داشت که با ساقط کردن یک تراکنش نمی‌توان
به تنهایی مشکل بن‌بست را حل کرد بلکه باعث ایجاد مشکل جدیدی به نام قحطی خواهد شد.
برای مثال یک تراکنش که قصد زدن قفل x روی داده‌ای است منتظر دنباله‌ای از
تراکنش‌ها بماند که همگی می‌خواهند قفل s را روی همان منبع (داده) بزنند و این
انتظار به پایان نرسد می‌گویم در این حالت تراکنش تعریف قفل x روی منبع دچار قحطی
شده است.

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{قحطی}
        \end{RTL}
        \centering
            \begin{tabular}{c|c|c|c|c}
                $T_{1}$ & S(Q) & & & U(Q) \\ \hline
                $T_{2}$ & & X(Q) & & \\ \hline
                $T_{3}$ & & & S(Q) & \\ \hline
                $T_{4}$ & & & & S(Q) \\ \hline
                $...$ & & & & \\ 
            \end{tabular}
    \end{table}
\end{LTR}

در تراکنش‌های بالا به دلیل انتظار نامجدود ممکن است قحطی بین تراکنش‌های دیگر پیش
آید، به دلیل آنکه همه می‌خواهند روی یک منبع عملیاتی را انجام دهند که در تراکنش
اول قفل خواندن در دست است و تراکنش‌های دیگر باید منتظر آزاد سازی آن باشند.

\newpage

\subsection{پروتکل‌های قفل دو مرحله‌ای 2 2PL}

برای توضیح این پروتکل‌ها تراکنش‌های زیر را در نظر بگیرید:

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{زمانبندی $S_{5}$}
        \end{RTL}
        \centering
        \scalebox{0.6}{
            \begin{tabular}{c|ccccccccccccccc}
                $T_{1}$ & x(A) & Dec(A, amount) & w(A) & u(A) & & & & & & & x(B) & Inc(B, amount) & w(B) & u(B) &  \\ \hline
                $T_{2}$ & & & & & s(A) & r(A) & s(B) & r(B) & Dis(A+B) & u(A) & u(B) & & & &  \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

در جدول ۱۶، شما تراکنش‌هایی را می‌بینید که در حال کم کردن از یک منبع و اضافه
کردن آن مقدار به منبع دیگری هستند. ولی این تراکنش‌ها صحیح نیستند و دیتابیس
نمی‌تواند به درستی کار کند چرا که با بازیابی ناسازگار رو به رو است. با توجه به
تراکنش $T_{2}$ می‌توان دریافت که بعد از قفل گذاری روی منبع A برای خواندن، سعی در
قفل گذاری رو منبع B دارد که اصلا معتبر نیست. زیرا در تراکنش $T_{1}$ هیچ عملیات
یا حتی قفل گذاری روی منبع B انجام نشده است که الان سعی در خواندن آن دارد. پس با
بازیابی ناهمگام یا \lr{Inconsistent retrieval} رو به رو خواهد بود و باید از یک
پروتکل قفل گذاری مناسب چهت این کار استفاده کند.

نکته: اگر زمابندی پی در پی پذیر در برخورد باشد آنگاه تمام مشکلات مربوط به
همروندی تراکنش‌ها برطرف خواهد شد.

\subsubsection{مراحلی که در فرایند پروتکل 2PL برای قفل گذاری صورت می‌گیرد}

\subsubsection*{مرحله اول - مرحله رشد یا \lr{Growing}}

در این مرحله تراکنش می‌تواند قفل گذاری کند (احتمال انجام کار را دارد)، اما
نمی‌تواند قفل را آزاد کند.

\subsubsection*{مرحله دوم - مرحله عقب نشینی یا \lr{Shrinking}}

در این مرحله تراکنش می‌تواند قفل را آزاد کند (احتمال انجام کار دارد)، اما
نمی‌تواند روی منبعی قفل گذاری جدیدی را انجام دهد.

\newpage

\subsection{پروتکل B2PL یا \lr{Basic Two Phase Locking}}

در این مرحله، تراکنش‌ها شروع به قفل گذاری منابع برای انجام عملیات خود می‌کنند به
محض اینکه یکی از تراکنش‌ها قفلی را آزاد کند وارد مرحله دوم یا Shrinking خواهد شد
و از این بعد نمی‌تواند هیچ قفل گذاری را انجام دهد.


\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{زمانبندی $S_{6}$}
        \end{RTL}
        \centering
        \scalebox{0.6}{
            \begin{tabular}{c|ccccccccccccccc}
                $T_{1}$ & x(A) & Dec(A, amount) & w(A) & x(B) & Inc(B, amount) & u(A) & W(B) & u(B) & & & & & & &  \\ \hline
                $T_{2}$ & & & & & & & & & & & s(B) & r(B) & Disp(A+B) & u(A) & u(B)  \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

این پروتکل قفل گذاری ترمیم پذیر نخواهد بود چرا که مشکل بین‌بست و سقوط‌های آبشاری
را دارد. برای رفع این مشکلات پروتکل دیگری به نام C2PL یا قفل گذاری محافظه کارانه
را معرفی کردند.

\subsection{قفل گذاری C2PL یا \lr{Conservative Two Phase Locking}}

در این پروتکل قبل از اجرای هر دستور و عملیاتی، تراکنش‌ها بایستی قفل‌های مورد
نیاز را از قبل گرفته باشند اگر موفق نشد دوباره در صف قرار می‌گیرد (تا اینکه
قفل‌های قبلی باز شوند و بتواند قفل جدیدی را تعریف کند).

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{زمانبندی $S_{7}$}
        \end{RTL}
        \centering
        \scalebox{0.5}{
            \begin{tabular}{c|ccccccccccccccccc}
                $T_{1}$ & x(A) & x(B) & Dec(A, amount) & w(A) & Inc(B, anount) & u(A) & w(B) & u(B) & C & & & & & & & &  \\ \hline
                $T_{2}$ & & & & & & & & & s(A) & s(B) & r(A) & u(A) & r(B) & Disp(A+B) & u(B) & C   \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

مهم‌ترین مشکلات این روش پایین آمدن سطح سرعت همروندی و نیاز به دانستن مجموعه
قفل‌های مورد نیاز هر تراکنش قبل از شروع اجرای دستورات می‌باشد. امکان بن‌بست در
این روش از بین می‌رود اما باز هم ترمیم پذیر نخواهد بود فلذا می‌تواند باعث رخ
دادن سقوط آبشاری شود. استفاده از این پروتکل گران است چرا که برای تضمین عدم وقوع
بن‌بست، سرعت و کارایی همروندی را تا حد چشمگیری کاهش می‌دهد در حالی که در دنیای
واقعی احتمال بروز بن‌بست آنقدر زیاد نمی‌باشد.

\newpage

\subsection{پروتکل S2PL یا \lr{Strict Two Phase Locking}}

در این پروتکل علاوه‌بر بن‌بست، امکان سقوط آبشاری نیز وجود دارد اما به طور کلی در
این پروتکل بعد از قفل گذاری‌ها، ابتدا تراکنش بایستی کامیت یا Abort شود و سپس
قفل‌هایی که در اختیار دارد را آزاد کند. قفل‌های خواندن می‌تواند کمی زودتر بعد از
آخرین دستور تراکنش یا قبل از کامیت یا Abort باز شوند وگرنه در بقیه عملیات شبیه
B2PL عمل می‌کند. اگرچه این پروتکل کمی سختگیرانه عمل می‌کند و شاید بسیاری از
زمانبندی‌ها که در واقع درست هستند را به دلیل احتمال بروز مشکل نپذیرد، اما به
عنوان یکی از بهترین گزینه‌ها در اکثر سیستم‌های دیتابیسی مورد استفاده قرار گرفته
است. مزیت اصلی این پروتکل که آنرا به پرکاربردترین و بهترین گزینه تبدیل کرده است،
تمضین پی در پی پذیری و ترمیم پذیری است.

از مزیت دیگر این پروتکل می‌توان به کم کردن پیام‌ها در بانک‌های اطلاعاتی نامتمرکز
اشاره کرد زیرا نیازی به پیام‌های باز کردن قفل ندارد.

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{زمانبندی $S_{8}$}
        \end{RTL}
        \centering
        \scalebox{0.5}{
            \begin{tabular}{c|ccccccccccccccccc}
                $T_{1}$ & x(A) & Dec(A, amount) & w(A) & x(B) & Inc(B, Amount) & w(B) & c & u(A) & u(B) & & & & & & & & \\ \hline
                $T_{2}$ & & & & & & & & & & s(A) & r(A) & s(B) & r(B) & Disp(A+B) & c & u(A) & u(B) \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

نکات و بررسی S2PL با R2PL

\begin{enumerate}
    \item پروتکل‌های S2PL و R2PL تنها پروتکل‌هایی که مبتنی بر قفل اند که هم پی
    در پی پذیری هم ترمیم پذیری و فاقد سقوط‌های ابشاری هستند.
    \item پروتکل S2PL نسبت به R2PL همروندی بیشتری را فراهم می‌کند، علاوه‌بر این
    کارایی یکسانی را ارائه می‌دهد.
\end{enumerate}

\subsection{پروتکل SC2PL}

این پروتکل ترکیبی از دو پروتکل S2PL و C2PL برای بهروری و کارایی بیشتر است. در
این پروتکل بن‌بست و گرسنگی و سقوط آبشاری وجود ندارد! عملکرد این پروتکل با خواندن
دو پروتکل ترکیبی آن حاصل می‌شود.

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{زمانبندی $S_{9}$}
        \end{RTL}
        \centering
        \scalebox{0.5}{
            \begin{tabular}{c|ccccccccccccccccc}
                $T_{1}$ & x(A) & x(B) & Dec(A, amount) & w(A) & Inc(B, amount) & w(B) & c & u(A) & u(B) & & & & & & & & \\ \hline
                $T_{2}$ & & & & & & & s(A) & & s(B) & r(A) & r(B) & Disp(A+B) & c & u(A) & u(B) & & \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

\newpage

مثال: معادل زمانبندی زیر را یکبار با قفل باینری و یکبار با قفل s/x و رعایت
پروتکل B2PL بنویسید:


همین تمرین را با پروتکل‌های C2PL، S2PL و SC2PL آنجام دهید.
\end{document}