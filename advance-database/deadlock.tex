\section{روش‌های مدیریت بن‌بست}

همان طور که در بخش‌های قبلی نوشته شد، زمانی سیستم دچار بن‌بست می‌شود که تو
تراکنش قفل‌های یکدیگر را درخواست کرده باشند یا اینکه مجموعه‌ای از تراکنش‌ها برای
همیشه منتظر یکدیگر برای دریافت قفل باشند.

مهم‌ترین استراتژی‌های مدیریت بن‌بست موارد زیر می‌باشد

\subsection{چشم پوشی یا \lr{Ignore}}

در عمل اتفاق بن‌بست بسیار پایین و هزینه مقابله با آن گران است به همین خاطر یکی
از روش‌های مقابله با بن‌بست چشم پوشی کردن از آن است.  یک نوع وابستگی خارج از سطح
سیستم است که معمولا برنامه‌نویس یا مدیر سیستم (یا هر عامل دیگری) مسئول برطرف
کردن آن است.

\subsection{فرصت یا \lr{Timeout}}

تراکنشی که به حالت انتظار می‌رود، فقط برای مدت زمان معینی منتظر می‌ماند (اگر
سرویس نگرفت) پس از آن ساقط می‌شود و دوباره بایستی درخواست اجرایش انجام شود. این
روش یک روش ساده است که از بن‌بست جلوگیری می‌کند ولی امکان بروز قحطی در آن زیاد
است. مقدار timeout در سیستم کار مشکل و پیچیده‌ای است.

\subsection{پیشگیری یا \lr{Prevention}}

استفاده از پروتکل‌هایی که نبود بن‌بست را تضمین می‌کنند، مانند:

\begin{itemize}
    \item پروتکل SC2PL
    \item پروتکل C2PL
    \item استفاده از timestamp به شرطی که رد شدن در آن به معنای انتظار نباشد
    بلکه به معنای Rollback باشد.
\end{itemize}

\subsection{اجتناب یا \lr{Avoidance}}

در این روش بن‌بست تشخیص داده می‌شود و از اجرای دستوری که موجب آن شود جلوگیری به
عمل می‌آورد. در این روش از مهر زمانی مخصوص بن‌بست استفاده می‌کنیم. دو حالت دارد:

\begin{itemize}
    \item روش \lr{Wait die}: تراکنش پیرتر (با timestamp کمتر) منتظر می‌ماند که
    تراکنش جوان‌تر قفل مربوطه را آزاد کند. در مقابل تراکنش جوان‌تر هرگز منتظر
    نمی‌ماند بلکه ساقط می‌شود (می‌میرد). ممکن است یک تراکنش چندین بار بمیرد.
    
    \item روش \lr{Wound wait}: در این روش تراکنش پیرتر به جای انتظار تراکنش
    جوان‌تر را می‌کشد (kill) ولی تراکنش جوان‌تر منتظر تراکنش پیرتر می‌ماند. در
    این روش برخلاف روش \lr{Wait die} تراکنش پیرتر اولویت بالاتری دارد و با گشتن
    تراکنش جوان فرایند اجرا را به قبضه خود در می‌آورد.
\end{itemize}

\subsection*{نکته}

تعداد تراکنش‌های جوان‌تر که منتظر هستند بیشتر از تراکنش‌هایی با مهر زمانی پیرتر
است. در هر دو روش گفته شده، تراکنشی که ساقط می‌شود با همان مهر زمانی اصلی خود
(مثلا ثانیه ۱۰ وارد شده و زمان کنونی ثانیه ۱۰۰ است پس ۱۰ از ۱۰۰ پیرتر خواهد بود)
آغاز به کار مجدد می‌کند که به همین دلیل باعث می‌شود تراکنش جوان پس از چند بار
مردن، بالاخره پیر شود و بتواند تراکنش را قبضه کند و از بروز قحطی جلوگیری کند.

\subsection{تشخیص و رفع بن‌بست یا \lr{Detection and resolve}}

در این روش از گراف انتظار استفاده می‌کنیم. به ازای تمام حالاتی‌ که بین
تراکنش‌های $T_i$ و $T_j$ حالت‌های WW و WR و RW رخ می‌دهد را یک یال می‌کشیم. اگر
در گراف دور ایجاد شود بن‌بست رخ داده است. در این حالت باید تراکنشی که تعداد
دور‌های بیشتری دارد را kill کنیم تا دور از بین برود یا اینکه تشخیص دهیم که کدام
تراکنش کار بیشتری انجام داده است که اگر اکثر فرایندش را انجام داده در پایان کار
آن را kill کنیم.

\newpage