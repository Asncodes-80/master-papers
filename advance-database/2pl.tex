\subsection{پروتکل‌های قفل دو مرحله‌ای 2PL}

برای توضیح این پروتکل‌ها تراکنش‌های زیر را در نظر بگیرید:

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{زمانبندی $S_{5}$}
            \label{fig:s5}
        \end{RTL}
        \centering
        \scalebox{0.83}{
            \begin{tabular}{c|ccccccccccccccc}
                $T_{1}$ & x(A) & Dec(A, amount) & w(A) & u(A) & & & & & & & x(B) & Inc(B, amount) & w(B) & u(B) &  \\ \hline
                $T_{2}$ & & & & & s(A) & r(A) & s(B) & r(B) & Dis(A+B) & u(A) & u(B) & & & &  \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

در جدول شماره \ref{fig:s5}، شما تراکنش‌هایی را می‌بینید که در حال کم کردن از یک
منبع و اضافه کردن آن مقدار به منبع دیگری هستند. ولی این تراکنش‌ها صحیح نیستند و
دیتابیس نمی‌تواند به درستی کار کند چرا که با بازیابی ناسازگار رو به رو است. با
توجه به تراکنش $T_{2}$ می‌توان دریافت که بعد از قفل گذاری روی منبع A برای
خواندن، سعی در قفل گذاری رو منبع B دارد که اصلا معتبر نیست. زیرا در تراکنش
$T_{1}$ هیچ عملیات یا حتی قفل گذاری روی منبع B انجام نشده است که الان سعی در
خواندن آن دارد. پس با بازیابی ناهمگام یا \lr{Inconsistent retrieval} رو به رو
خواهد بود و باید از یک پروتکل قفل گذاری مناسب جهت این کار استفاده کند.

\subsection*{نکته}

اگر زمابندی پی در پی پذیر در برخورد باشد آنگاه تمام مشکلات مربوط به
همروندی تراکنش‌ها برطرف خواهد شد.

\subsection{مراحلی که در فرایند پروتکل 2PL برای قفل گذاری صورت می‌گیرد}

\subsection*{مرحله اول - مرحله رشد یا \lr{Growing}}

در این مرحله تراکنش می‌تواند قفل گذاری کند (احتمال انجام کار را دارد)، اما
نمی‌تواند قفل را آزاد کند.

\subsubsection*{مرحله دوم - مرحله عقب نشینی یا \lr{Shrinking}}

در این مرحله تراکنش می‌تواند قفل را آزاد کند (احتمال انجام کار دارد)، اما
نمی‌تواند روی منبعی قفل گذاری جدیدی را انجام دهد.

\newpage

\subsection{پروتکل B2PL یا \lr{Basic Two Phase Locking}}

در این مرحله، تراکنش‌ها شروع به قفل گذاری منابع برای انجام عملیات خود می‌کنند به
محض اینکه یکی از تراکنش‌ها قفلی را آزاد کند وارد مرحله دوم یا Shrinking خواهد شد
و از این بعد نمی‌تواند هیچ قفل گذاری را انجام دهد.


\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{زمانبندی $S_{6}$}
        \end{RTL}
        \centering
        \scalebox{0.73}{
            \begin{tabular}{c|cccccccccccccccc}
                $T_{1}$ & X(A) & Dec(A, amount) & W(A) & X(B) & Inc(B, amount) & U(a) & & & W(B) & U(B) & & & & & &  \\ \hline
                $T_{2}$ & & & & & & & S(A) & R(A) & & & S(B) & R(B) & Dis(A+B) & U(A) & U(B) &   \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

این پروتکل قفل گذاری ترمیم پذیر نخواهد بود چرا که مشکل بن‌بست و سقوط‌های آبشاری
را دارد. برای رفع این مشکلات پروتکل دیگری به نام C2PL یا قفل گذاری محافظه کارانه
را معرفی کردند.

\subsection{قفل گذاری C2PL یا \lr{Conservative Two Phase Locking}}

در این پروتکل قبل از اجرای هر دستور و عملیاتی، تراکنش‌ها بایستی قفل‌های مورد
نیاز را از قبل گرفته باشند اگر موفق نشد دوباره در صف قرار می‌گیرد (تا اینکه
قفل‌های قبلی باز شوند و بتواند قفل جدیدی را تعریف کند).

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{زمانبندی $S_{7}$}
        \end{RTL}
        \centering
        \scalebox{0.73}{
            \begin{tabular}{c|ccccccccccccccccc}
                $T_{1}$ & X(A) & X(B) & Dec(A, amount) & W(A) & Inc(B, amount) & W(B) & U(A) & & & U(B) & C & & & & & & \\ \hline
                $T_{2}$ & & & & & & & & S(A) & R(A) & & & S(B) & R(B) & U(A) & Disp(A+B) & U(B) & C \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

مهم‌ترین مشکلات این روش پایین آمدن سطح سرعت همروندی و نیاز به دانستن مجموعه
قفل‌های مورد نیاز هر تراکنش قبل از شروع اجرای دستورات می‌باشد. امکان بن‌بست در
این روش از بین می‌رود اما باز هم ترمیم پذیر نخواهد بود فلذا می‌تواند باعث رخ
دادن سقوط آبشاری شود. استفاده از این پروتکل گران است چرا که برای تضمین عدم وقوع
بن‌بست، سرعت و کارایی همروندی را تا حد چشمگیری کاهش می‌دهد در حالی که در دنیای
واقعی احتمال بروز بن‌بست آنقدر زیاد نمی‌باشد.

\subsection{پروتکل S2PL یا \lr{Strict Two Phase Locking}}

به طور کلی در این پروتکل بعد از قفل گذاری‌ها، ابتدا تراکنش بایستی کامیت یا Abort
شود و سپس قفل‌هایی که در اختیار دارد را آزاد می‌کند. قفل‌های خواندن می‌تواند کمی
زودتر بعد از آخرین دستور تراکنش یا قبل از کامیت یا Abort باز شوند وگرنه در بقیه
عملیات شبیه B2PL عمل می‌کند. اگرچه این پروتکل کمی سختگیرانه عمل می‌کند و شاید
بسیاری از زمانبندی‌ها که در واقع درست هستند را به دلیل احتمال بروز مشکل نپذیرد،
اما به عنوان یکی از بهترین گزینه‌ها در اکثر سیستم‌های دیتابیسی مورد استفاده قرار
گرفته است. مزیت اصلی این پروتکل که آنرا به پرکاربردترین و بهترین گزینه تبدیل
کرده است، تضمین پی در پی پذیری و ترمیم پذیری است. از مزیت دیگر این پروتکل
می‌توان به کم کردن پیام‌ها در بانک‌های اطلاعاتی نامتمرکز اشاره کرد زیرا نیازی به
پیام‌های باز کردن قفل ندارد.

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{زمانبندی $S_{8}$}
        \end{RTL}
        \centering
        \scalebox{0.73}{
            \begin{tabular}{c|ccccccccccccccccc}
                $T_{1}$ & X(A) & Dec(A, amount) & W(A) & X(B) & Inc(B, amount) & W(B) & \textbf{C} & U(A) & & U(B) & & & & & & & \\ \hline
                $T_{2}$ & & & & & & & & & S(A) & & R(A) & S(B) & R(B) & Disp(A+B) & \textbf{C} & U(A) & U(B)  \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

\subsection*{نکات و بررسی SS2PL یا R2PL}

\begin{enumerate}
    \item این پروتکل همانطور که از نامش پیداست (\lr{Strong Strict}) سختگیرانه‌تر
    از S2PL می‌باشد و معمولا استفاده نمی‌شود.
    \item در این پروتکل قفل‌های خواندن و نوشتن یا S و X باید بعد از Abort یا
    Commit آزاد شوند.
\end{enumerate}

\subsection{پروتکل SC2PL}

این پروتکل ترکیبی از دو پروتکل S2PL و C2PL برای بهروری و کارایی بیشتر است. در
این پروتکل بن‌بست و گرسنگی و سقوط آبشاری وجود ندارد! عملکرد این پروتکل با خواندن
دو پروتکل ترکیبی آن حاصل می‌شود. اما کمترین میزان همروندی را خواهد داشت.

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{زمانبندی $S_{9}$}
        \end{RTL}
        \centering
        \scalebox{0.73}{
            \begin{tabular}{c|ccccccccccccccccc}
                $T_{1}$ & X(A) & X(B) & Dec(A, amount) & W(A) & Inc(B, amount) & W(B) & \textbf{C} & U(A) & & U(B) & & & & & & & \\ \hline
                $T_{2}$ & & & & & & & & & S(A) & & S(B) & R(A) & R(B) & Disp(A+B) & \textbf{C} & U(A) & U(B) \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

\subsection*{مثال ۱}

معادل زمانبندی زیر را یکبار با قفل باینری و یکبار با قفل S/X و رعایت پروتکل B2PL
بنویسید:

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{زمانبندی $S_{10}$}
        \end{RTL}
        \centering
        \scalebox{0.87}{
            \begin{tabular}{c|c|c|c|c|c|c|c|c|c}
                $T_{1}$ & R(Q) & & & & W(Q) & & & & \\ \hline
                $T_{2}$ & & R(A) & & & & & R(Q) & & \\ \hline
                $T_{3}$ & & & R(Q) & & & R(P) & & W(P) & \\ \hline
                $T_{4}$ & & & & W(Q) &  & & & & W(A) \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

\subsection*{قفل باینری}

\begin{LTR}
\centering
$L_1(Q)R_1(Q)L_2(A)R_2(A)[L_3(Q)L_4(Q)]W_1(Q)U_1(Q)C_1R_3(Q)L_3(P)R_3(P)[L_2(Q)]$

$W_3(P)U_3(Q)U_3(P)C_3[W_4(Q)]L_4(A)[Deadlock]$
\end{LTR}

\subsection*{قفل S/X}

\begin{LTR}
\centering
$S_10 = S_1^*(Q)R_1(Q) S_2^*(A)R_2(A) S_3^*(Q)R_3(Q) [X_4(Q)][X_1(Q)]S_3^*(P)R_3(P) S_2^*(Q)R_2(Q) U_2(A)U_2(Q)C2$

$X_3(P)W_3(P) U_3(Q)U_3(P)C_3W_1(Q)U_1(Q)C_1W_4(Q)X_4(A)W_4(A)U_4(Q)U_4(A)C_4$
\end{LTR}

\subsubsection*{نکته}

در این روش قفل گذاری به دلیل وجود ناسازگاری RW یا WR نمی‌توان به نوشتن‌ها به
دلیل خواندن‌های قبلی روی منبع مشترک قفل اختصاص داد. بلکه بایستی کار خواندن‌ها
روی آن منبع مشترک به طور کامل تمام شود تا قفل را آزاد کند و سپس به نوشتن‌ها
اختصاص یابد.

\subsection*{حل مسئله با قفل باینری، پروتکل S2PL}

\begin{LTR}
    \centering
    $L_1(Q)R_1(Q)L_2(A)R_2(A)[L_3(Q) wait][L_4(Q) wait]W_1(Q)C_1U_1(Q)$

    $[L_3(Q) wait \rightarrow granted R_3(Q)]L_3(P)R_3(P)$

    $[L_2(Q) wait]W_3(P)C_3U_3(Q)U_3(P)[L_4(Q) wait \rightarrow granted W_4(Q)];Deadlock;$
\end{LTR}

در مسئله بالا یک حلقه ایجاد می‌شود چرا که برای انجام کامل عملیات $T_4$ نیاز است
به صورت کامل این تراکنش انجام شود یعنی $W(A)$ نیز انجام شده و سپس قفل Q و A آزاد
شود، اما از آنجا که قفل دست منبع A در تارکنش $T_2$ است و $T_2$ تا انتها انجام
نشده چرا که هم $R_2(A)$ قفل A را آزاد نکرده است و عملیات $R_2(Q)$ نیز به دلیل
وابستگی به قفل $W_4(Q)$ هنوز قادر به بدست آوردن قفل Q نیست، پس این فرایند دائم
تکرار شده و برای بدست آوردن قفل‌های منابع یکدیگر به بن‌بست بر می‌خورد.

\newpage