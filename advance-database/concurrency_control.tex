\section{پروتکل‌های کنترل همروندی}

بعد از دیدن دستور، ۳ کار انجام می‌شود:

\begin{enumerate}
    \item اجرای دستور
    \item به تاخیر انداختن دستور (ممکن است به دلایلی وارد صف شود برای بدست آوردن
    قفل)
    \item نپذیرفتن دستور یا سقوط آن
\end{enumerate}

\subsection{پروتکل‌های مبتنی بر قفل}

در این نوع پروتکل واحدی به نام \lr{Lock Manager} تراکنش‌ها را بررسی می‌کند، اگر
ناسازگاری ww wr یا rw وجود نداشته باشد اجازه خواندن را به تراکنش می‌دهد و سپس
بعد از آن که تراکنش کارش تمام شد می‌تواند قفل را تحویل دهد تا تراکنش بعدی بتواند
عملیات قفل گذاری را انجام دهد.

\subsection*{قفل‌ها دو نوع هستند}

\begin{enumerate}
    \item قفل‌های دو حالته (دودویی): هیچ تفاوتی ندارد که تراکنش می‌خواهد بخواند
    یا بنویسد، به هر صورت قفل را اختصاص می‌دهد و در این فرایند هم تنها یک قفل
    برای هر دو عمل خواندن و نوشتن وجود دارد
    \item قفل‌های اشتراکی-انحصاری یا \lr{Shared Exclusive Lock}: از یک قفل برای
    خواندن (S) استفاده می‌کند و از قفل دیگر برای نوشتن (X)
\end{enumerate}

\subsection*{نکات}

\begin{itemize}
    \item مزیت قفل‌های اشتراکی-انحصاری در انجام تراکنش‌ها به صورت موازی است
    \item اگه قفل به حالت ناسازگار برسد آن تراکنش را به تاخیر می‌اندازد
    \item قفل گذاری روی داده‌های زیاد با Seed بالا همروندی را کاهش می‌دهد
    \item وقتی Seed کم باشد Overhead زمانی خواهیم داشت و پردازش گران است
    \item منظور از Seed در حقیقت منبعی است که می‌خواهیم روی آن قفل گذاری کنیم
    \item منابع مورد قفل گذاری می‌تواند یک ویژگی از جدول، یک جدول با رکورد‌های
    متفاوت و یا حتی یک \lr{OS Page Table} باشد
    \item قفل گذاری درست باعث می‌شود تا زمانبندی درست داشته باشیم
    \item زمانی که بر روی یک Table قفل می‌گذاریم، روی داده‌های بیشتری قفل گذاشته
    می‌شود و داده‌های بیشتری از دسترس خارج می‌شود که در نهایت همراه با همروندی
    کمتر است
    \item در قفل گذاری اشتراکی-انحصاری چندین تراکنش می‌توانند به طور همزمان قفل
    S را بدست آورند. زیرا حالت Read-Read پدید می‌آید  و حالت سازگاری است و مشکلی
    ایجاد نمی‌کند.
    \item حالت ناسازگار زمانی است که یک تراکنش بخواهد قفل S را بدست آورد و دیگری
    می‌خواهد قفل X را بدست آورد.
\end{itemize}

\subsection*{نوشتار}

\begin{itemize}
    \item $S_i(Q)$: دریافت قفل اشتراکی برای عملیات خواندن
    \item $X_i(Q)$: دریافت قفل انحصاری برای عملیات نوشتن
    \item $U_i(Q)$: آزادسازی قفل روی منبع Q
\end{itemize}

\subsection*{مثال ۱}

\begin{equation}
    S_{1} = R_{1}(A) W_{1}(A) A_{1} W_{2}(A) W_{2}(B) C
\end{equation}

\subsection*{پاسخ مثال ۱}

\begin{LTR}
    \centering
    $S_{1}$ = $S_{1}(A)$ $R_{1}(A)$ $X_{1}(A)$ $W_{1}(A)$ $U_{1}(A)$ $A_{1}$ $X_{2}(A)$ $W_{2}(A)$ $X_{2}(B)$ $W_{2}(B)$ $U_{2}(A)$ $U_{2}(B)$ $C$
\end{LTR}

\subsection*{مثال کلید اشتراکی-انحصاری}

\begin{LTR}
    \begin{table}[h]
        \centering
        \scalebox{0.8}{
            \begin{tabular}{c|c|c|c|c|c}
                $T_{3}$ & & & W(Q) & & \\ \hline
                $T_{4}$ & R(Q) & & & W(Q) & \\ \hline
                $T_{5}$ & & W(Q) & & & \\ \hline
                $T_{6}$ & & & & & R(Q) \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

\subsection*{تبدیل جدول به سریال}

\begin{LTR}
    $R_{4}(Q)$ $W_{5}(Q)$ $W_{3}(Q)$ $W_{4}(Q)$ $R_{5}(Q)$
\end{LTR}

\subsection*{حل}

\begin{LTR}
    \centering
    $\rightarrow$ 
    $S_{4}(Q)$ $R_{4}(Q)$ 
    $X_{5}(Q)$ $X_{3}(Q)$
    $X_{4}(Q)$ $W_{4}(Q)$ $U_{4}(Q)$
    $W_{5}(Q)$ $U_{5}(Q)$
    $W_{3}(Q)$ $U_{3}(Q)$
    $S_{6}(Q)$ $R_{6}(Q)$ $U_{6}(Q)$
\end{LTR}

در این مسئله به دلیل وجود دو درخواست \footnote{\lr{Request}} در تراکنش $T_4$
ابتدا قفل به خواندن منبع Q اختصاص داده می‌شود ولی بعد از آن قفل آزاد نمی‌شود، تا
زمانی که این تراکنش به طور کامل کارش را انجام دهد و تمام شود. بعد از آن یکی یکی
تراکنش‌ها می‌توانند به درخواست‌هایشان برسند و عمل خواندن را از صف خارج کرده و
بعد از انجام موفقیت آمیز عملیات خواندن قفل را آزاد کنند.

\newpage

\subsection{بن بست و قحطی}

سوال: چه زمانی بن‌بست یا DeadLock رخ می‌دهد؟ زمانی که یک پردازه (تراکنش) منتظر
بدست آوردن قفل پردازه (تراکنش) مقابلش باشد. مهم‌ترین راهکار برای کم کردن بن‌بست
حذف یا Abort تراکنش باعث بن‌بست است.

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{شکل کلی بن‌بست}
        \end{RTL}
        \centering
            \begin{tabular}{c|c}
                $T_1$ & $T_2$ \\ \hline
                \lr{Lock(A)} & \lr{Lock(B)} \\
                \lr{Lock(B)} & \lr{Lock(A)} \\
            \end{tabular}
    \end{table}
\end{LTR}

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{نمونه‌ای از تراکنش‌هایی که به بن‌بست بر خورده‌اند}
        \end{RTL}
        \centering
            \begin{tabular}{c|c|c|c|c|c}
                $T_{3}$ & x(B) & w(B) & & & x(A) \\ \hline
                $T_{4}$ & & s(A) & r(A) & s(B) & \\
            \end{tabular}
    \end{table}
\end{LTR}

جدول بالا به دلیل ناسازگاری WR و RW به بن‌بست بر می‌خورد. چرا که در تراکنش
$T_{3}$ برای نوشتن روی منبع B قفل نوشتن گذاشته شده است ولی Unlock نشده است و
تراکنش $T_{4}$ نمی‌تواند قفل خواندن را روی منبع A بگذارد چرا که تراکنش $T_{3}$
هنوز قفل را آزاد نکرده است. در این حالت یک انتظار چرخشی یا \lr{Unlimited wating}
بین تراکنش‌ها رخ داده است که دائما منتظر آزاد سازی قفل یکدگیر هستند تا بتوانند
بقیه عملیات را انجام دهند. در $T_4$ قفل خواندن روی منبع A گذاشته می‌شود و بعد از
آن در خواست قفل گذاری را روی منبع B را دارد در حالی $T_3$ دقیقا روی منبع B عمل
نوشتن را انجام می‌دهد و قفل را رها نکرده است و در مقابل در ادامه همین تراکنش
درخواست نوشتن روی منبع A را دارد که در تراکنش $T_4$ درخواست آن داده شده ولی هیچ
قفلی آزاد نشده است. دلیل اصلی بن‌بست همین است.

بایستی در نظر داشت که با ساقط کردن یک تراکنش نمی‌توان به تنهایی مشکل بن‌بست را
حل کرد بلکه باعث ایجاد مشکل جدیدی به نام قحطی خواهد شد.  برای مثال یک تراکنشی که
قصد زدن قفل x روی داده‌ای را دارد باید منتظر دنباله‌ای از تراکنش‌ها بماند که
همگی می‌خواهند قفل s را روی همان منبع (داده) بزنند و اگر این انتظار به پایان
نرسد، می‌گویم در این حالت تراکنش تعریف قفل x روی منبع دچار قحطی شده است.

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{قحطی}
        \end{RTL}
        \centering
            \begin{tabular}{c|c|c|c|c}
                $T_{1}$ & S(Q) & & & U(Q) \\ \hline
                $T_{2}$ & & X(Q) & & \\ \hline
                $T_{3}$ & & & S(Q) & \\ \hline
                $T_{4}$ & & & & S(Q) \\ \hline
                $...$ & & & & \\ 
            \end{tabular}
    \end{table}
\end{LTR}

در تراکنش‌های بالا به دلیل انتظار نامحدود ممکن است قحطی بین تراکنش‌های دیگر پیش
آید، به دلیل آنکه همه می‌خواهند روی یک منبع، عملیاتی را انجام دهند که در تراکنش
اول قفل خواندن در دست است و تراکنش‌های دیگر باید منتظر آزاد سازی آن باشند.

\newpage

\input{2pl}