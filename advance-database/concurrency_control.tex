\section{پروتکل‌های کنترل همروندی}

بعد از دیدن دستور، ۳ کار انجام می‌شود:

\begin{enumerate}
    \item اجرای دستور
    \item به تاخیر انداختن دستور (ممکن است به دلایلی وارد صف شود برای بدست آوردن
    قفل)
    \item نپذیرفتن دستور یا سقوط آن
\end{enumerate}

\subsection{پروتکل‌های مبتنی بر قفل}

در این نوع پروتکل واحدی به نام \lr{Lock Manager} تراکنش‌ها را بررسی می‌کند، اگر
ناسازگاری ww wr یا rw وجود نداشته باشد اجازه خواندن را به تراکنش می‌دهد و سپس
بعد از آن که تراکنش کارش تمام شد می‌تواند قفل را تحویل دهد تا تراکنش بعدی بتواند
عملیات قفل گذاری را انجام دهد.

\subsection*{قفل‌ها دو نوع هستند}

\begin{enumerate}
    \item قفل‌های دو حالته (دودویی): هیچ تفاوتی ندارد که تراکنش می‌خواهد بخواند
    یا بنویسد، به هر صورت قفل را اختصاص می‌دهد و در این فرایند هم تنها یک قفل
    برای هر دو عمل خواندن و نوشتن وجود دارد
    \item قفل‌های اشتراکی-انحصاری یا \lr{Shared Exclusive Lock}: از یک قفل برای
    خواندن (S) استفاده می‌کند و از قفل دیگر برای نوشتن (X)
\end{enumerate}

\subsection*{نکات}

\begin{itemize}
    \item مزیت قفل‌های اشتراکی-انحصاری در انجام تراکنش‌ها به صورت موازی است
    \item اگه قفل به حالت ناسازگار برسد آن تراکنش را به تاخیر می‌اندازد
    \item قفل گذاری روی داده‌های زیاد با Seed بالا همروندی را کاهش می‌دهد
    \item وقتی Seed کم باشد Overhead زمانی خواهیم داشت و پردازش گران است
    \item منظور از Seed در حقیقت منبعی است که می‌خواهیم روی آن قفل گذاری کنیم
    \item منابع مورد قفل گذاری می‌تواند یک ویژگی از جدول، یک جدول با رکورد‌های
    متفاوت و یا حتی یک \lr{OS Page Table} باشد
    \item قفل گذاری درست باعث می‌شود تا زمانبندی درست داشته باشیم
    \item زمانی که بر روی یک Table قفل می‌گذاریم، روی داده‌های بیشتری قفل گذاشته
    می‌شود و داده‌های بیشتری از دسترس خارج می‌شود که در نهایت همراه با همروندی
    کمتر است
    \item در قفل گذاری اشتراکی-انحصاری چندین تراکنش می‌توانند به طور همزمان قفل
    S را بدست آورند. زیرا حالت Read-Read پدید می‌آید  و حالت سازگاری است و مشکلی
    ایجاد نمی‌کند.
    \item حالت ناسازگار زمانی است که یک تراکنش بخواهد قفل S را بدست آورد و دیگری
    می‌خواهد قفل X را بدست آورد.
\end{itemize}

\subsection*{نوشتار}

\begin{itemize}
    \item $S_i(Q)$: دریافت قفل اشتراکی برای عملیات خواندن
    \item $X_i(Q)$: دریافت قفل انحصاری برای عملیات نوشتن
    \item $U_i(Q)$: آزادسازی قفل روی منبع Q
\end{itemize}

\newpage

\subsection*{مثال ۱}

\begin{equation}
    S_{1} = R_{1}(A) W_{1}(A) A_{1} W_{2}(A) W_{2}(B) C
\end{equation}

\subsection*{پاسخ مثال ۱}

\begin{LTR}
    \centering
    $S_{1}$ = $S_{1}(A)$ $R_{1}(A)$ $X_{1}(A)$ $W_{1}(A)$ $U_{1}(A)$ $A_{1}$ $X_{2}(A)$ $W_{2}(A)$ $X_{2}(B)$ $W_{2}(B)$ $U_{2}(A)$ $U_{2}(B)$ $C$
\end{LTR}

\subsection*{مثال کلید اشتراکی-انحصاری}

\begin{LTR}
    \begin{table}[h]
        \centering
        \scalebox{0.8}{
            \begin{tabular}{c|c|c|c|c|c}
                $T_{3}$ & & & W(Q) & & \\ \hline
                $T_{4}$ & R(Q) & & & W(Q) & \\ \hline
                $T_{5}$ & & W(Q) & & & \\ \hline
                $T_{6}$ & & & & & R(Q) \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

\subsection*{تبدیل جدول به سریال}

\begin{LTR}
    $R_{4}(Q)$ $W_{5}(Q)$ $W_{3}(Q)$ $W_{4}(Q)$ $R_{5}(Q)$
\end{LTR}

\subsection*{حل}

\begin{LTR}
    \centering
    $\rightarrow$ 
    $S_{4}(Q)$ $R_{4}(Q)$ 
    $X_{5}(Q)$ $X_{3}(Q)$
    $X_{4}(Q)$ $W_{4}(Q)$ $U_{4}(Q)$
    $W_{5}(Q)$ $U_{5}(Q)$
    $W_{3}(Q)$ $U_{3}(Q)$
    $S_{6}(Q)$ $R_{6}(Q)$ $U_{6}(Q)$
\end{LTR}

در این مسئله به دلیل وجود دو درخواست \footnote{\lr{Request}} در تراکنش $T_4$
ابتدا قفل به خواندن منبع Q اختصاص داده می‌شود ولی بعد از آن قفل آزاد نمی‌شود، تا
زمانی که این تراکنش به طور کامل کارش را انجام دهد و تمام شود. بعد از آن یکی یکی
تراکنش‌ها می‌توانند به درخواست‌هایشان برسند و عمل خواندن را از صف خارج کرده و
بعد از انجام موفقیت آمیز عملیات خواندن قفل را آزاد کنند.

\newpage

\subsection{بن بست و قحطی}

سوال: چه زمانی بن‌بست یا DeadLock رخ می‌دهد؟ زمانی که یک پردازه (تراکنش) منتظر
بدست آوردن قفل باشد. مهم‌ترین راهکار برای کم کردن بن‌بست حذف یا Abort تراکنش
باعث بن‌بست است.

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{شکل کلی بن‌بست}
        \end{RTL}
        \centering
            \begin{tabular}{c|c}
                $T_1$ & $T_2$ \\ \hline
                \lr{Lock(A)} & \lr{Lock(B)} \\
                \lr{Lock(B)} & \lr{Lock(A)} \\
            \end{tabular}
    \end{table}
\end{LTR}

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{نمونه‌ای از تراکنش‌هایی که به بن‌بست بر خورده‌اند}
        \end{RTL}
        \centering
            \begin{tabular}{c|c|c|c|c|c}
                $T_{3}$ & x(B) & w(B) & & & x(A) \\ \hline
                $T_{4}$ & & s(A) & r(A) & s(B) & \\
            \end{tabular}
    \end{table}
\end{LTR}

جدول بالا به دلیل ناسازگاری WR و RW به بن‌بست بر می‌خورد. چرا که در تراکنش
$T_{3}$ برای نوشتن روی منبع B قفل نوشتن گذاشته شده است ولی Unlock نشده است و
تراکنش $T_{4}$ نمی‌تواند قفل خواندن را روی منبع A بگذارد چرا که تراکنش $T_{3}$
هنوز قفل را آزاد نکرده است. در این حالت یک انتظار چرخشی یا \lr{Unlimited wating}
بین تراکنش‌ها رخ داده است که دائما منتظر آزاد سازی قفل یکدگیر هستند تا بتوانند
بقیه عملیات را انجام دهند. در $T_4$ قفل خواندن روی منبع A گذاشته می‌شود و بعد از
آن در خواست قفل گذاری را روی منبع B را دارد در حالی $T_3$ دقیقا روی منبع B عمل
نوشتن را انجام می‌دهد و قفل را رها نکرده است و در مقابل در ادامه همین تراکنش
درخواست نوشتن روی منبع A را دارد که در تراکنش $T_4$ درخواست آن داده شده ولی هیچ
قفلی آزاد نشده است. دلیل اصلی بن‌بست همین است.

بایستی در نظر داشت که با ساقط کردن یک تراکنش نمی‌توان به تنهایی مشکل بن‌بست را
حل کرد بلکه باعث ایجاد مشکل جدیدی به نام قحطی خواهد شد.  برای مثال یک تراکنش که
قصد زدن قفل x روی داده‌ای است منتظر دنباله‌ای از تراکنش‌ها بماند که همگی
می‌خواهند قفل s را روی همان منبع (داده) بزنند و این انتظار به پایان نرسد می‌گویم
در این حالت تراکنش تعریف قفل x روی منبع دچار قحطی شده است.

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{قحطی}
        \end{RTL}
        \centering
            \begin{tabular}{c|c|c|c|c}
                $T_{1}$ & S(Q) & & & U(Q) \\ \hline
                $T_{2}$ & & X(Q) & & \\ \hline
                $T_{3}$ & & & S(Q) & \\ \hline
                $T_{4}$ & & & & S(Q) \\ \hline
                $...$ & & & & \\ 
            \end{tabular}
    \end{table}
\end{LTR}

در تراکنش‌های بالا به دلیل انتظار نامحدود ممکن است قحطی بین تراکنش‌های دیگر پیش
آید، به دلیل آنکه همه می‌خواهند روی یک منبع عملیاتی را انجام دهند که در تراکنش
اول قفل خواندن در دست است و تراکنش‌های دیگر باید منتظر آزاد سازی آن باشند.

\newpage

\subsection{پروتکل‌های قفل دو مرحله‌ای 2PL}

برای توضیح این پروتکل‌ها تراکنش‌های زیر را در نظر بگیرید:

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{زمانبندی $S_{5}$}
        \end{RTL}
        \centering
        \scalebox{0.83}{
            \begin{tabular}{c|ccccccccccccccc}
                $T_{1}$ & x(A) & Dec(A, amount) & w(A) & u(A) & & & & & & & x(B) & Inc(B, amount) & w(B) & u(B) &  \\ \hline
                $T_{2}$ & & & & & s(A) & r(A) & s(B) & r(B) & Dis(A+B) & u(A) & u(B) & & & &  \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

در جدول ۱۶، شما تراکنش‌هایی را می‌بینید که در حال کم کردن از یک منبع و اضافه
کردن آن مقدار به منبع دیگری هستند. ولی این تراکنش‌ها صحیح نیستند و دیتابیس
نمی‌تواند به درستی کار کند چرا که با بازیابی ناسازگار رو به رو است. با توجه به
تراکنش $T_{2}$ می‌توان دریافت که بعد از قفل گذاری روی منبع A برای خواندن، سعی در
قفل گذاری رو منبع B دارد که اصلا معتبر نیست. زیرا در تراکنش $T_{1}$ هیچ عملیات
یا حتی قفل گذاری روی منبع B انجام نشده است که الان سعی در خواندن آن دارد. پس با
بازیابی ناهمگام یا \lr{Inconsistent retrieval} رو به رو خواهد بود و باید از یک
پروتکل قفل گذاری مناسب جهت این کار استفاده کند.

\subsection*{نکته}

اگر زمابندی پی در پی پذیر در برخورد باشد آنگاه تمام مشکلات مربوط به
همروندی تراکنش‌ها برطرف خواهد شد.

\subsection{مراحلی که در فرایند پروتکل 2PL برای قفل گذاری صورت می‌گیرد}

\subsection*{مرحله اول - مرحله رشد یا \lr{Growing}}

در این مرحله تراکنش می‌تواند قفل گذاری کند (احتمال انجام کار را دارد)، اما
نمی‌تواند قفل را آزاد کند.

\subsubsection*{مرحله دوم - مرحله عقب نشینی یا \lr{Shrinking}}

در این مرحله تراکنش می‌تواند قفل را آزاد کند (احتمال انجام کار دارد)، اما
نمی‌تواند روی منبعی قفل گذاری جدیدی را انجام دهد.

\newpage

\subsection{پروتکل B2PL یا \lr{Basic Two Phase Locking}}

در این مرحله، تراکنش‌ها شروع به قفل گذاری منابع برای انجام عملیات خود می‌کنند به
محض اینکه یکی از تراکنش‌ها قفلی را آزاد کند وارد مرحله دوم یا Shrinking خواهد شد
و از این بعد نمی‌تواند هیچ قفل گذاری را انجام دهد.


\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{زمانبندی $S_{6}$}
        \end{RTL}
        \centering
        \scalebox{0.73}{
            \begin{tabular}{c|cccccccccccccccc}
                $T_{1}$ & X(A) & Dec(A, amount) & W(A) & X(B) & Inc(B, amount) & U(a) & & & W(B) & U(B) & & & & & &  \\ \hline
                $T_{2}$ & & & & & & & S(A) & R(A) & & & S(B) & R(B) & Dis(A+B) & U(A) & U(B) &   \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

این پروتکل قفل گذاری ترمیم پذیر نخواهد بود چرا که مشکل بن‌بست و سقوط‌های آبشاری
را دارد. برای رفع این مشکلات پروتکل دیگری به نام C2PL یا قفل گذاری محافظه کارانه
را معرفی کردند.

\subsection{قفل گذاری C2PL یا \lr{Conservative Two Phase Locking}}

در این پروتکل قبل از اجرای هر دستور و عملیاتی، تراکنش‌ها بایستی قفل‌های مورد
نیاز را از قبل گرفته باشند اگر موفق نشد دوباره در صف قرار می‌گیرد (تا اینکه
قفل‌های قبلی باز شوند و بتواند قفل جدیدی را تعریف کند).

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{زمانبندی $S_{7}$}
        \end{RTL}
        \centering
        \scalebox{0.73}{
            \begin{tabular}{c|ccccccccccccccccc}
                $T_{1}$ & X(A) & X(B) & Dec(A, amount) & W(A) & Inc(B, amount) & W(B) & U(A) & & & U(B) & C & & & & & & \\ \hline
                $T_{2}$ & & & & & & & & S(A) & R(A) & & & S(B) & R(B) & U(A) & Disp(A+B) & U(B) & C \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

مهم‌ترین مشکلات این روش پایین آمدن سطح سرعت همروندی و نیاز به دانستن مجموعه
قفل‌های مورد نیاز هر تراکنش قبل از شروع اجرای دستورات می‌باشد. امکان بن‌بست در
این روش از بین می‌رود اما باز هم ترمیم پذیر نخواهد بود فلذا می‌تواند باعث رخ
دادن سقوط آبشاری شود. استفاده از این پروتکل گران است چرا که برای تضمین عدم وقوع
بن‌بست، سرعت و کارایی همروندی را تا حد چشمگیری کاهش می‌دهد در حالی که در دنیای
واقعی احتمال بروز بن‌بست آنقدر زیاد نمی‌باشد.

\subsection{پروتکل S2PL یا \lr{Strict Two Phase Locking}}

به طور کلی در این پروتکل بعد از قفل گذاری‌ها، ابتدا تراکنش بایستی کامیت یا Abort
شود و سپس قفل‌هایی که در اختیار دارد را آزاد می‌کند. قفل‌های خواندن می‌تواند کمی
زودتر بعد از آخرین دستور تراکنش یا قبل از کامیت یا Abort باز شوند وگرنه در بقیه
عملیات شبیه B2PL عمل می‌کند. اگرچه این پروتکل کمی سختگیرانه عمل می‌کند و شاید
بسیاری از زمانبندی‌ها که در واقع درست هستند را به دلیل احتمال بروز مشکل نپذیرد،
اما به عنوان یکی از بهترین گزینه‌ها در اکثر سیستم‌های دیتابیسی مورد استفاده قرار
گرفته است. مزیت اصلی این پروتکل که آنرا به پرکاربردترین و بهترین گزینه تبدیل
کرده است، تمضین پی در پی پذیری و ترمیم پذیری است. از مزیت دیگر این پروتکل
می‌توان به کم کردن پیام‌ها در بانک‌های اطلاعاتی نامتمرکز اشاره کرد زیرا نیازی به
پیام‌های باز کردن قفل ندارد.

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{زمانبندی $S_{8}$}
        \end{RTL}
        \centering
        \scalebox{0.73}{
            \begin{tabular}{c|ccccccccccccccccc}
                $T_{1}$ & X(A) & Dec(A, amount) & W(A) & X(B) & Inc(B, amount) & W(B) & \textbf{C} & U(A) & & U(B) & & & & & & & \\ \hline
                $T_{2}$ & & & & & & & & & S(A) & & R(A) & S(B) & R(B) & Disp(A+B) & \textbf{C} & U(A) & U(B)  \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

\subsection*{نکات و بررسی SS2PL یا R2PL}

\begin{enumerate}
    \item این پروتکل همانطور که از نامش پیداست (\lr{Strong Strict}) سختگیرانه‌تر
    از S2PL می‌باشد و معمولا استفاده نمی‌شود.
    \item در این پروتکل قفل‌های خواندن و نوشتن یا S و X باید بعد از Abort یا
    Commit آزاد شوند.
\end{enumerate}

\subsection{پروتکل SC2PL}

این پروتکل ترکیبی از دو پروتکل S2PL و C2PL برای بهروری و کارایی بیشتر است. در
این پروتکل بن‌بست و گرسنگی و سقوط آبشاری وجود ندارد! عملکرد این پروتکل با خواندن
دو پروتکل ترکیبی آن حاصل می‌شود. اما کمترین میزان همروندی را خواهد داشت.

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{زمانبندی $S_{9}$}
        \end{RTL}
        \centering
        \scalebox{0.73}{
            \begin{tabular}{c|ccccccccccccccccc}
                $T_{1}$ & X(A) & X(B) & Dec(A, amount) & W(A) & Inc(B, amount) & W(B) & \textbf{C} & U(A) & & U(B) & & & & & & & \\ \hline
                $T_{2}$ & & & & & & & & & S(A) & & S(B) & R(A) & R(B) & Disp(A+B) & \textbf{C} & U(A) & U(B) \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

\subsection*{مثال ۱}

معادل زمانبندی زیر را یکبار با قفل باینری و یکبار با قفل S/X و رعایت پروتکل B2PL
بنویسید:

\begin{LTR}
    \begin{table}[h]
        \begin{RTL}
            \caption{زمانبندی $S_{10}$}
        \end{RTL}
        \centering
        \scalebox{0.87}{
            \begin{tabular}{c|c|c|c|c|c|c|c|c|c}
                $T_{1}$ & R(Q) & & & & W(Q) & & & & \\ \hline
                $T_{2}$ & & R(A) & & & & & R(Q) & & \\ \hline
                $T_{3}$ & & & R(Q) & & & R(P) & & W(P) & \\ \hline
                $T_{4}$ & & & & W(Q) &  & & & & W(A) \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

\subsection*{قفل باینری}

\begin{LTR}
\centering
$L_1(Q)R_1(Q)L_2(A)R_2(A)[L_3(Q)L_4(Q)]W_1(Q)U_1(Q)C_1R_3(Q)L_3(P)R_3(P)[L_2(Q)]$

$W_3(P)U_3(Q)U_3(P)C_3[W_4(Q)]L_4(A)[Deadlock]$
\end{LTR}

\subsection*{قفل S/X}

\begin{LTR}
\centering
$S_10 = S_1^*(Q)R_1(Q) S_2^*(A)R_2(A) S_3^*(Q)R_3(Q) [X_4(Q)][X_1(Q)]S_3^*(P)R_3(P) S_2^*(Q)R_2(Q) U_2(A)U_2(Q)C2$

$X_3(P)W_3(P) U_3(Q)U_3(P)C_3W_1(Q)U_1(Q)C_1W_4(Q)X_4(A)W_4(A)U_4(Q)U_4(A)C_4$
\end{LTR}

\subsubsection*{نکته}

در این روش قفل گذاری به دلیل وجود ناسازگاری RW یا WR نمی‌توان به نوشتن‌ها به
دلیل خواندن‌های قبلی روی منبع مشترک قفل اختصاص داد. بلکه بایستی کار خواندن‌ها
روی آن منبع مشترک به طور کامل تمام شود تا قفل را آزاد کند و سپس به نوشتن‌ها
اختصاص یابد.

\subsection*{حل مسئله با قفل باینری، پروتکل S2PL}

\begin{LTR}
    \centering
    $L_1(Q)R_1(Q)L_2(A)R_2(A)[L_3(Q) wait][L_4(Q) wait]W_1(Q)C_1U_1(Q)$

    $[L_3(Q) wait \rightarrow granted R_3(Q)]L_3(P)R_3(P)$

    $[L_2(Q) wait]W_3(P)C_3U_3(Q)U_3(P)[L_4(Q) wait \rightarrow granted W_4(Q)];Deadlock;$
\end{LTR}

در مسئله بالا یک حلقه ایجاد می‌شود چرا که برای انجام کامل عملیات $T_4$ نیاز است
به صورت کامل این تراکنش انجام شود یعنی $W(A)$ نیز انجام شده و سپس قفل Q و A آزاد
شود، اما از آنجا که قفل دست منبع A در تارکنش $T_2$ است و $T_2$ تا انتها انجام
نشده چرا که هم $R_2(A)$ قفل A را آزاد نکرده است و عملیات $R_2(Q)$ نیز به دلیل
وابستگی به قفل $W_4(Q)$ هنوز قادر به بدست آوردن قفل Q نیست، پس این فرایند دائم
تکرار شده و برای بدست آوردن قفل‌های منابع یکدیگر به بن‌بست بر می‌خورد.

\newpage