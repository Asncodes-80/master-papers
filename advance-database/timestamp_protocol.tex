\section{پروتکل‌های مبتنی بر مهر زمانی \lr{Timestamp}}

مهم‌ترین کاربرد را در دیتابیس‌های توزیع شده دارد. هر تراکنش به محض ورود، یک مهر
زمانی تصاعدی به آن داده می‌شود. مهر زمانی تراکنش $T_i$ را به صورت $TS(T_i)$
نمایش می‌دهیم. مسلم است که برای دو تراکنش $T_i$ و $T_j$ که $T_j$ دیرتر وارد
سیستم شده است به صورت $TS(T_i) < TS(T_j)$ می‌باشد. بر این اساس، پروتکل مبتنی بر
مهر زمانی، تراکنش‌ها را به  ترتیب مهر زمانی آن ها به صورت پی در پی پذیر اجرا
می‌کند. اکنون که این برگه نوشته می‌شود timestamp آن به صورت \lr{1703397265}
می‌باشد.  بعد از آن دوباره اقدام به تولید یک زمان دیگر کردیم که به مقدار
\lr{1703397306} رسیدیم. با مقایسه این دو زمان می‌توانید دریابید که زمان اول
زودتر از زمان دوم نوشته شده است پس کوچکتر می‌باشد اما سن آن چند ثانیه بیشتر
می‌باشد یا به طور کلی به شکل زیر آن را می‌نویسم:

\begin{equation}
    1703397265 < 1703397306 
\end{equation}

\subsection*{نکته}

برای هر داده Q مهر زمانی خواندن و نوشتن آن به صورت زیر تعریف می‌شود:

\begin{itemize}
    \item زمان $W-TS(Q)$: مهر زمانی نوشتن داده Q که برابر است با بزرگترین مهر
    زمانی تراکنشی که به طور موفقیت آمیز روی Q نوشته است.
    \item زمان $R-TS(Q)$: مهر زمانی خواندن Q که برابر است با بزرگ ترین مهر زمانی
    تراکنشی که به طور موفقیت آمیز Q را خوانده است.
\end{itemize}

\subsection{قواعد}

این قواعد تضمین می‌کنند که دستورات خواندن و نوشتن با هم برخورد دارند و به ترتیب
مهر زمانی اجرا خواهند شد و زمانبندی‌های مربوطه پی در پی پذیر هستند.

\subsubsection{قاعده خواندن}

تراکنش $T_i$ شامل یک دستور Read(Q) است آنگاه:

\begin{enumerate}
    \item اگر $TS(T_i) < W-TS(Q)$ آنگاه تراکنش $T_i$ داده‌ای را می‌خواند که
    مقدارش انگار بعداً نوشته می‌شود. پس در این صورت با دستور خواندن تراکنش
    موافقت نمی‌شود و تراکنش رد (Reject) خواهد شد.
    \begin{LTR}
        \begin{table}[h]
            \begin{RTL}
                \caption{بررسی مهر زمانی در قاعده خواندن}
            \end{RTL}
            \centering
            \scalebox{0.87}{
                \begin{tabular}{c|cc}
                    $T_{1}$ & R(Q) & \\ \hline
                    $T_{2}$ & & W(Q) \\
                \end{tabular}
            }
        \end{table}
    \end{LTR}

    \item اگر $TS(T_i) >= W-TS(Q)$ آنگاه دستور خواندن تراکنش $T_i$ اجرا می‌شود و
    مهر زمانی خواندن Q با \lr{Max} بین مهر زمانی تراکنش $T_i$ و مهر زمانی خواندن
    Q مقداردهی می‌شود

    \begin{LTR}
        \begin{table}[h]
            \begin{RTL}
                \caption{بررسی مهر زمانی در قاعده خواندن}
            \end{RTL}
            \centering
            \scalebox{0.87}{
                \begin{tabular}{c|cc}
                    $T_{1}$ & W(Q) & \\ \hline
                    $T_{2}$ & & R(Q) \\
                \end{tabular}
            }
        \end{table}
    \end{LTR}

\end{enumerate}

\subsubsection*{منظور از Reject شدن در چیست؟}

وقتی می‌گوییم تراکنش Reject یا رد خواهد شد یعنی آنکه یا ممکن است منتظر اجرا
(Wait) بماند یا ساقط و مجددا اجرا (\lr{Abort and Rollback}) شود.

\subsubsection{قاعده نوشتن}

تراکنش $T_i$ شامل یک دستور Write(Q) است آنگاه:

\begin{enumerate}
    \item اگر $TS(T_i) < W-TS(Q) || TS(T_i) < R-TS(Q)$ باشد، آنگاه با دستور
    نوشتن تراکنش موافقت نمی‌شود و تراکنش $T_i$ رد یا Reject می‌شود (اشاره به
    ناسازگاری \lr{WW} و \lr{WR}).

    \item در غیر این صورت دستور نوشتن اجرا می‌شود و مهر زمانی نوشتن Q نیز با
    $TS(T_i)$ مقداردهی می‌شود (اگر به صورت برعکس مورد بالا باشد یعنی: $TS(T_i) >
    R-TS(Q) \&\& TS(T_i) > W-TS(Q) $)
\end{enumerate}

\subsubsection*{نکات}

\begin{itemize}
    \item اگر هیچ تراکنشی به حالت رد شدن نرود این پروتکل‌ها فاقد بن‌بست خواهند
    بود اما ممکن است ترمیم پذیر نباشد.

    \item گراف زمانبندی‌های مهر زمانی همواره پی در پی پذیر خواهند بود چرا که
    همواره زمان در حال تغییر است و از زمان کوچک (سن بالاتر) به سمت زمان بزرگ‌تر
    (سن کوچک‌تر) می‌رود و هیچ دوری تشکیل نمی‌شود.
\end{itemize}

\subsection*{مثال}

زمانبندی زیر را با پروتکل‌های S2PL و C2PL و مهر زمانی بنویسید.

\begin{LTR}
    \centering
    $R_1(A),R_2(B),R_1(B),W_1(B),R_3(C),W_2(A)$
\end{LTR}

\newpage