\subsection*{یک زمانبندی ۲ شرط دارد که درست باشد:}

\begin{itemize}
    \item پی در پی پذیر باشد (قانون جامعیت در برخورد و دید برقرار باشد)
    \item ترمیم پذیر باشد
\end{itemize}

نکته: اگر یک زمانبندی پی در پی پذیر در برخورد باشد در دید هم پی در پی پذیر خواهد بود.

\section{ترمیم پذیری}

\subsection{مفهوم Rollback شدن}

اگر یک زمانبندی در میان اجرا Abort شود چون تراکنش‌های دیگر به آن وابسته هستند،
این تراکنش برای درست انجام شدن بایستی از اول انجام شود یا اصطلاحا Rollback صورت
گیرد.

\subsection{زمانبندی ترمیم پذیر یا \lr{Recoverable scheduling}}

زمانبندی را ترمیم پذیر می‌گوییم اگر $T_j$ از $T_i$ روی منبع اطلاعاتی خواندنی را
انجام می‌دهد که حتما به طور صحیح و کامل انجام شود. منظور از صحیح بودن آن است که
حتما تراکنش‌ها در زمانبندی Commit شده باشند. اما توجه شود که تراکنش قبلی بایستی
زودتر از تراکنش بعد خود Commit شده باشد.

\subsection*{مثال ۱: آیا زمانبندی زیر ترمیم پذیر است؟}

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{مثال ۱: بررسی ترمیم پذیری}
        \end{RTL}
        \begin{tabular}{c|c|c|c|c|c}
            $T_{1}$ & R(A) & W(A) & & R(B) & A \\ \hline
            $T_{2}$ & & & R(A) & & C \\
        \end{tabular}
    \end{table}
\end{LTR}

این زمانبندی ترمیم پذیر نیست چرا که درست نیست. زیرا در زمانبندی $T_{1}$ بعد از
انجام تراکنش عمل سقوط یا Abort اتفاق افتاده است و $T_{2}$ در حال خواندن مقدار از
منبعی از زمانبندی بالاتر خود است که تراکنش‌اش به دلیل \lr{Dirty Read} RollBack
خواهد شد و به صورت صحیح کامل نشده است.

\subsection*{مثال ۲: ترمیم پذیری زمانبندی زیر را بررسی کنید}

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{مثال ۲: بررسی ترمیم پذیری}
        \end{RTL}
        \begin{tabular}{c|c|c|c|c|c|c}
            $T_{1}$ & R(A) & W(A) & W(B) & C & \\ \hline
            $T_{2}$ & & & R(A) & W(A) & R(B) & C \\
        \end{tabular}
    \end{table}
\end{LTR}

این زمانبندی RC می‌باشد چرا که تراکنش‌ها به صورت صحیح انجام شد‌اند (عمل Commit
شدن در تراکنش‌ها وجود دارد). نکته مهم در این زمانبندی آن است که به دلیل وابسته
بودن عملیات تراکنش‌ها به یکدیگر ممکن است دائما در حال بررسی وجود Commit در
تراکنش‌ها باشیم تا زمانی عمل Abort رخ ندهد (اشاره به تراکنش دوم زمانی خواندن روی
منبع A صورت گرفته است). به همین دلیل زمانبندی ACA در اینجا تعریف خواهد شد. زمانی
تراکنش بالا می‌تواند ACA باشد که اولین خواندن دقیقا بعد از کامیت تراکنش اول صورت
گیرد.

\subsection{سقوط‌های آبشاری یا \lr{Cascading Aborts}}

در جدول ۱۲، دقیقا مانند مثال ۲، تمام تراکنش‌ها به همان شکل است. اما به جای کامیت
شدن در این جا تراکنش اول در نهایت سقوط می‌کند، هبا شکل دیگر ترمیم پذیر نخواهد
بود و با سقوط‌های آبشاری رو به رو است (اشاره به عملیات R(A) و R(B) که نوبتی سقط
می‌شوند).

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{بررسی سقوط‌های آبشاری در مثال ۲}
        \end{RTL}
        \scalebox{0.9}{
            \begin{tabular}{c|c|c|c|c|c|c}
                $T_{1}$ & R(A) & W(A) & W(B) & A & \\ \hline
                $T_{2}$ & & & R(A) & W(A) & R(B) & C \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

\subsection{\lr{Avoiding Cascading Aborts}}

در حقیقت فرایند زمانی فاقد سقوط آبشاری است; اگر $T_{j}$ از $T_{i}$ بخواند آنگاه
$T_{i}$ قبل از خواندن $T_{j}$ کامیت شده باشد. بطور کل به آن ACA می‌گویند که جز
تراکنش‌های ترمیم پذیر می‌باشد. به بیانی دیگر اگر قبل از اولین Read در تراکنش
دوم، در تراکنش اول کامیت صورت گرفته باشد آن زمانبندی ACA می‌باشد.

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{نمونه‌ای از فرایند ACA}
        \end{RTL}
        \scalebox{0.7}{
            \begin{tabular}{c|c|c|c|c|c|c|c|c|c}
                $T_{1}$ & R(A) & R(B) & W(A) & C & & & & & \\ \hline
                $T_{2}$ & & & & & R(A) & W(A) & C & & \\ \hline
                $T_{3}$ & & & & & & & & R(A) & C \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

\subsection*{نکات}

\begin{itemize}
    \item در پی در پی پذیری تنها در مورد مشکلات همروندی صحبت می‌شد
    \item در زمانبندی‌های ACA هدف آن است که اول کامیت انجام شود و سپس خواندن
    منبع صورت گیرد در غیر این صورت زمان برای خواندن مقداری که تثبیط نشده است صرف
    می‌شود و زمان اصلی برای انجام فرایند‌های دیگر را از دست خواهیم داد.
    \item یکی از قوانین ترمیم پذیری عدم وجود سقوط‌های آبشاری است، پس اگر یک
    زمانبندی ACA باشد پس ترمیم پذیر می‌باشد.
\end{itemize}

\subsection*{سوال، زمانبندی زیر را از نظر ACA و RC بررسی کنید}

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{بررسی زمانبندی مثال ۴}
        \end{RTL}
        \scalebox{0.9}{
            \begin{tabular}{c|c|c|c|c|c|c|c}
                $T_{1}$ & R(A) & W(A) & W(B) & C & & & \\ \hline
                $T_{2}$ & & W(B) & W(C) & W(D) & R(A) & R(B) & C \\
            \end{tabular}
        }
    \end{table}
\end{LTR}

این زمانبندی ACA می‌باشد چرا که اولین Read در تراکنش $T_j$ دقیقا بعد از کامیت
تراکنش $T_i$ صورت گرفته است.

\subsection{زمانبندی‌های محض (سختگیرانه) یا Strict}

در دو تراکنش $T_{i}$ و $T_{j}$، اگر $T_{j}$ داده‌ای را پس از نوشتن $T_{i}$
بخواند یا بنویسد بایستی قبل از آن Commit صورت گرفته باشد.

\subsection*{مثال ۵: زمانبندی زیر را از نظر محض بودن، ترمیم پذیری و ACA بررسی کنید}

\begin{LTR}
    \begin{table}[h]
        \centering
        \begin{RTL}
            \caption{مثال ۵: بررسی تمام لایه‌های ترمیم پذیری}
        \end{RTL}
        \scalebox{0.9}{
            \begin{tabular}{c|c|c|c|c|c|c}
                $T_{1}$ & R(A) & R(B) & W(A) & & C & \\ \hline
                $T_{2}$ & & & & W(A) & W(B) & C \\ 
            \end{tabular}
        }
    \end{table}
\end{LTR}

\begin{itemize}
    \item زمانبندی بالا محض نیست، چرا که بعد از نوشتن در تراکنش $T_i$ بایستی
    کامیت گذاشته شود و سپس تراکنش $T_j$ می‌تواند خواندن و نوشتن خود را انجام
    دهد. در این مثال تراکنش دوم خواندن یا نوشتن خود را بعد از کامیت نوشتن تراکنش
    اول انجام نداده است.
    \item در این مثال به دلیل آنکه خواندنی بعد از کامیت صورت نگرفته (اشاره به
    قانون ACA می‌باشد) و تراکنش‌ها هر دو کامیت شده‌اند و یک زمانبندی صحیح
    می‌باشد، پس ترمیم پذیر می‌باشد.
\end{itemize}

نکته: سیستم DBM از یکسری پروتکل‌هایی برای \underline{پی در پی پذیری} و
\underline{ترمیم پذیری} استفاده می‌کند تا دیتابیس به شکل صحیح کار کند. (پیروی از
دو شرط اصلی)